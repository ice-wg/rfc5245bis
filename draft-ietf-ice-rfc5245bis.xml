<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc='yes'?>
<?rfc tocdepth='5'?>
<?rfc symrefs='yes'?>

<?rfc compact='yes'?>
<?rfc subcompact='no'?>

<rfc ipr="pre5378Trust200902" category="std" obsoletes="5245"
     docName="draft-ietf-ice-rfc5245bis-09"
>

    <front>
    <title abbrev="ICE">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</title>

    <author fullname="Ari Keranen" initials="A." surname="Keranen">
      <organization abbrev="Ericsson">Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <city>02420 Jorvas</city>
          <country>Finland</country>
        </postal>
        <email>ari.keranen@ericsson.com</email>
      </address>
    </author>

    <author fullname="Christer Holmberg" initials="C." surname="Holmberg">
      <organization abbrev="Ericsson">Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <city>02420 Jorvas</city>
          <country>Finland</country>
        </postal>
        <email>christer.holmberg@ericsson.com</email>
      </address>
    </author>

    <author initials="J.R." surname="Rosenberg"
	    fullname="Jonathan Rosenberg">
      <organization>jdrosen.net</organization>
      <address>
	<postal>
	  <street/>
	  <city>Monmouth</city> <region>NJ</region>
	  <country>US</country>
	</postal>
	<email>jdrosen@jdrosen.net</email>
	<uri>http://www.jdrosen.net</uri>
      </address>
    </author>

        <date year="2017" />

        <area>ART</area>
        <workgroup>ICE</workgroup>
        <keyword>NAT</keyword>
        <abstract>
            <t>This document describes a protocol for Network Address
            Translator (NAT) traversal for UDP-based multimedia. This
            protocol is called Interactive Connectivity Establishment
            (ICE). ICE makes use of the Session Traversal Utilities
            for NAT (STUN) protocol and its extension, Traversal Using
            Relay NAT (TURN).</t>

	    <t> This document obsoletes RFC 5245. </t>
        </abstract>
    </front>

<middle>

<section title="Introduction">

<t>Protocols establishing multimedia sessions between peers typically
involve exchanging IP addresses and ports for the media sources and
sinks. However this poses challenges when operated through Network Address
Translators (NATs) <xref target="RFC3235"/>. These protocols also seek to
create a media flow directly between participants, so that there is
no application layer intermediary between them.  This is done to
reduce media latency, decrease packet loss, and reduce the
operational costs of deploying the application.  However, this is
difficult to accomplish through NATs.  A full treatment of the reasons
for this is beyond the scope of this specification.  </t>

<t> Numerous solutions have been defined for allowing these protocols
to operate through NATs. These include Application Layer Gateways
(ALGs), the <xref target="RFC3303"> Middlebox Control Protocol</xref>,
the original <xref target="RFC3489">Simple Traversal of UDP Through
NAT (STUN)</xref> specification, and <xref target="RFC3102">Realm
Specific IP</xref> <xref target="RFC3103"/> along with session
description extensions needed to make them work, such as the Session
Description Protocol (SDP) <xref target="RFC4566"/> attribute for the
Real Time Control Protocol (RTCP) <xref
target="RFC3605"/>. Unfortunately, these techniques all have pros and
cons which, make each one optimal in some network topologies, but a
poor choice in others. The result is that administrators and
implementors are making assumptions about the topologies of the
networks in which their solutions will be deployed. This introduces
complexity and brittleness into the system. What is needed is a single
solution that is flexible enough to work well in all situations.  </t>

<t> This specification defines Interactive Connectivity Establishment
(ICE) as a technique for NAT traversal for UDP-based media streams
(though ICE has been extended to handle other transport protocols,
such as TCP <xref target="RFC6544"/>). ICE works by exchanging a
multiplicity of IP addresses and ports which are then tested for
connectivity by peer-to-peer connectivity checks. The IP addresses and
ports are exchanged via mechanisms (for example, including in a
offer/answer exchange) and the connectivity checks are performed using
Session Traversal Utilities for NAT (STUN) specification <xref
target="RFC5389"/>. ICE also makes use of Traversal Using Relays
around NAT (TURN) <xref target="RFC5766"/>, an extension to STUN.
Because ICE exchanges a multiplicity of IP addresses and ports for
each media stream, it also allows for address selection for multihomed
and dual-stack hosts, and for this reason it deprecates <xref
target="RFC4091"/> and <xref target="RFC4092"/>.
</t>

</section>

<section title="Overview of ICE">

<t> In a typical ICE deployment, we have two endpoints (known as ICE
AGENTS) that want to communicate.  They are able to communicate
indirectly via some signaling protocol (such as SIP), by which they
can exchange ICE candidates. Note that ICE is not intended for NAT
traversal for the signaling protocol, which is assumed to be provided
via another mechanism. At the beginning of the ICE process, the agents
are ignorant of their own topologies.  In particular, they might or
might not be behind a NAT (or multiple tiers of NATs). ICE allows the
agents to discover enough information about their topologies to
potentially find one or more paths by which they can communicate.
</t>

<t>
<xref target="fig-ice-ref-arch"/> shows a typical environment for ICE
deployment. The two endpoints are labelled L and R (for left and
right, which helps visualize call flows). Both L and R are behind
their own respective NATs though they may not be aware of it. The type
of NAT and its properties are also unknown. Agents L and R are capable
of engaging in an candidate exchange process, whose purpose is to set
up a media session between L and R. Typically, this exchange will
occur through a signaling (e.g., SIP) server.
</t>

<t>
In addition to the agents, a signaling server and NATs, ICE is
typically used in concert with STUN or TURN servers in the
network. Each agent can have its own STUN or TURN server, or they can
be the same.
</t>

<figure title="ICE Deployment Scenario" anchor="fig-ice-ref-arch"
align="center"><artwork>
<![CDATA[
                  +---------+
+--------+        |Signaling|         +--------+
| STUN   |        |Server   |         | STUN   |
| Server |        +---------+         | Server |
+--------+       /           \        +--------+
                /             \
               /               \
              / <- Signaling -> \
             /                   \
      +--------+               +--------+
      |  NAT   |               |  NAT   |
      +--------+               +--------+
        /                             \
       /                               \
   +-------+                       +-------+
   | Agent |                       | Agent |
   |   L   |                       |   R   |
   +-------+                       +-------+
]]></artwork></figure>


<t>The basic idea behind ICE is as follows: each agent has a variety
of candidate TRANSPORT ADDRESSES (combination of IP address and port
for a particular transport protocol, which is always UDP in this
specification) it could use to communicate with the other agent. These
might include:
<list style="symbols">
<t>A transport address on a directly attached network interface</t>

<t>A translated transport address on the public side of a NAT (a "server
reflexive" address)</t>

<t>A transport address allocated from a TURN server (a "relayed
  address")</t>

</list>
</t>

<t>
Potentially, any of L's candidate transport addresses can be used to
communicate with any of R's candidate transport addresses. In
practice, however, many combinations will not work. For instance, if L
and R are both behind NATs, their directly attached interface
addresses are unlikely to be able to communicate directly (this is why
ICE is needed, after all!). The purpose of ICE is to discover which
pairs of addresses will work.  The way that ICE does this is to
systematically try all possible pairs (in a carefully sorted order)
until it finds one or more that work.
</t>

<section title="Gathering Candidate Addresses">
<t>
In order to execute ICE, an agent has to identify all of its address
candidates. A CANDIDATE is a transport address -- a combination of IP
address and port for a particular transport protocol (with only UDP
specified here). This document defines three types of candidates, some
derived from physical or logical network interfaces, others
discoverable via STUN and TURN.  Naturally, one viable candidate is a
transport address obtained directly from a local interface. Such a
candidate is called a HOST CANDIDATE. The local interface could be
Ethernet or WiFi, or it could be one that is obtained through a tunnel
mechanism, such as a Virtual Private Network (VPN) or Mobile IP
(MIP). In all cases, such a network interface appears to the agent as
a local interface from which ports (and thus candidates) can be
allocated.
</t>

<t> If an agent is multihomed, it obtains a candidate from each IP
address. Depending on the location of the PEER (the other agent in the
session) on the IP network relative to the agent, the agent may be
reachable by the peer through one or more of those IP
addresses. Consider, for example, an agent that has a local IP address
on a private net 10 network (I1), and a second connected to the public
Internet (I2). A candidate from I1 will be directly reachable when
communicating with a peer on the same private net 10 network, while a
candidate from I2 will be directly reachable when communicating with a
peer on the public Internet. Rather than trying to guess which IP
address will work, the initiating agent sends both the candidates to its
peer.
</t>

<t> Next, the agent uses STUN or TURN to obtain additional
candidates. These come in two flavors: translated addresses on the
public side of a NAT (SERVER REFLEXIVE CANDIDATES) and addresses on
TURN servers (RELAYED CANDIDATES). When TURN servers are utilized,
both types of candidates are obtained from the TURN server. If only
STUN servers are utilized, only server reflexive candidates are
obtained from them.  The relationship of these candidates to the host
candidate is shown in <xref target="fig-address-types"/>.  In this
figure, both types of candidates are discovered using TURN. In the
figure, the notation X:x means IP address X and UDP port x.
</t>

<figure title="Candidate Relationships" anchor="fig-address-types">
<artwork>
<![CDATA[

              To Internet

                  |
                  |
                  |  /------------  Relayed
              Y:y | /               Address
              +--------+
              |        |
              |  TURN  |
              | Server |
              |        |
              +--------+
                  |
                  |
                  | /------------  Server
           X1':x1'|/               Reflexive
            +------------+         Address
            |    NAT     |
            +------------+
                  |
                  | /------------  Local
              X:x |/               Address
              +--------+
              |        |
              | Agent  |
              |        |
              +--------+

]]></artwork></figure>

<t> When the agent sends the TURN Allocate request from IP address and
port X:x, the NAT (assuming there is one) will create a binding
X1':x1', mapping this server reflexive candidate to the host candidate
X:x. Outgoing packets sent from the host candidate will be translated
by the NAT to the server reflexive candidate.  Incoming packets sent
to the server reflexive candidate will be translated by the NAT to the
host candidate and forwarded to the agent. The host candidate
associated with a given server reflexive candidate is the BASE.
</t>

<t>
When there are multiple NATs between the agent and the TURN server,
the TURN request will create a binding on each NAT, but only the
outermost server reflexive candidate (the one nearest the TURN server)
will be discovered by the agent. If the agent is not behind a NAT,
then the base candidate will be the same as the server reflexive
candidate and the server reflexive candidate is redundant will be
eliminated.
</t>

<t>
The Allocate request then arrives at the TURN server. The TURN server
allocates a port y from its local IP address Y, and generates an
Allocate response, informing the agent of this relayed candidate. The
TURN server also informs the agent of the server reflexive candidate,
X1':x1' by copying the source transport address of the Allocate
request into the Allocate response. The TURN server acts as a packet
relay, forwarding traffic between L and R. In order to send traffic to
L, R sends traffic to the TURN server at Y:y, and the TURN server
forwards that to X1':x1', which passes through the NAT where it is
mapped to X:x and delivered to L.
</t>

<t>
When only STUN servers are utilized, the agent sends a STUN Binding
request <xref target="RFC5389"/> to its STUN server. The STUN server
will inform the agent of the server reflexive candidate X1':x1' by
copying the source transport address of the Binding request into the
Binding response.
</t>

</section>

<section title="Connectivity Checks">
<t>
Once L has gathered all of its candidates, it orders them in highest
to lowest-priority and sends them to R over the signaling
channel. When R receives the candidates from L, it performs the same
gathering process and responds with its own list of candidates. At the
end of this process, each agent has a complete list of both its
candidates and its peer's candidates. It pairs them up, resulting in
CANDIDATE PAIRS.  To see which pairs work, each agent schedules a
series of CHECKS. Each check is a STUN request/response transaction
that the client will perform on a particular candidate pair by sending
a STUN request from the local candidate to the remote candidate.
</t>

<t>
The basic principle of the connectivity checks is simple:
<list style="numbers">
<t>Sort the candidate pairs in priority order.</t>
<t>Send checks on each candidate pair in priority order.</t>
<t>Acknowledge checks received from the other agent.</t>
</list>
With both agents performing a check on a candidate pair, the result is
a 4-way handshake:
</t>

<figure title="Basic Connectivity Check"
anchor="fig:connectivity-checks" align="center"><artwork>
<![CDATA[
L                        R
-                        -
STUN request ->             \  L's
          <- STUN response  /  check

           <- STUN request  \  R's
STUN response ->            /  check
]]></artwork></figure>

<t>
It is important to note that the STUN requests are sent to and from
the exact same IP addresses and ports that will be used for media
(e.g., RTP and RTCP). Consequently, agents demultiplex STUN and
media using contents of the packets, rather than the port on which
they are received.
</t>

<t>
Because a STUN Binding request is used for the connectivity check, the
STUN Binding response will contain the agent's translated transport
address on the public side of any NATs between the agent and its
peer. If this transport address is different from that of other candidates the
agent already learned, it represents a new candidate, called a PEER
REFLEXIVE CANDIDATE, which then gets tested by ICE just the same as
any other candidate.
</t>

<t>
As an optimization, as soon as R gets L's check message, R schedules a
connectivity check message to be sent to L on the same candidate
pair. This accelerates the process of finding a valid candidate, and
is called a TRIGGERED CHECK.
</t>

<t>
At the end of this handshake, both L and R know that they can
send (and receive) messages end-to-end in both directions.
</t>

</section>


<section title="Sorting Candidates">

<t>
Because the algorithm above searches all candidate pairs, if a working
pair exists it will eventually find it no matter what order the
candidates are tried in. In order to produce faster (and better)
results, the candidates are sorted in a specified order. The resulting
list of sorted candidate pairs is called the CHECK LIST. The algorithm
is described in <xref target="sec-prioritizing"/> but follows two
general principles:
<list style="symbols">
<t>Each agent gives its candidates a numeric priority, which is sent
along with the candidate to the peer.</t>
<t>The local and remote priorities are combined so that each
agent has the same ordering for the candidate pairs.</t>
</list>
</t>

<t>
The second property is important for getting ICE to work when there
are NATs in front of L and R. Frequently, NATs will not allow packets
in from a host until the agent behind the NAT has sent a packet
towards that host. Consequently, ICE checks in each direction will not
succeed until both sides have sent a check through their respective
NATs.
</t>

<t>
The agent works through this check list by sending a STUN request for
the next candidate pair on the list periodically. These are called
ORDINARY CHECKS.
</t>

<t>
In general, the priority algorithm is designed so that candidates of
similar type get similar priorities and so that more direct routes
(that is, through fewer media relays and through fewer NATs) are
preferred over indirect ones (ones with more media relays and more
NATs).  Within those guidelines, however, agents have a fair amount of
discretion about how to tune their algorithms.
</t>

</section>

<section title="Frozen Candidates">

<t> The previous description only addresses the case where the agents
wish to establish a media session with one COMPONENT (a piece of a
media stream requiring a single transport address; a media stream may
require multiple components, each of which has to work for the media
stream as a whole to be work).</t>

<t>
The network properties are likely to be very similar for each
component. It is usually possible to leverage
information from one media component in order to determine the best
candidates for another. ICE does this with a mechanism called "frozen
candidates".
</t>

<t>
Each candidate is associated with a property called its
FOUNDATION. Two candidates have the same foundation when they are
"similar" -- of the same type and obtained from the same host
candidate and STUN/TURN server using the same protocol. Otherwise,
their foundation is different. A candidate pair has a foundation too,
which is just the concatenation of the foundations of its two
candidates. Initially, only candidate pairs with unique
foundations are tested and other candidate pairs are marked
"frozen". When connectivity checks succeed,
other candidate pairs with the same foundation are unfrozen. This
avoids repeated checking of components that are superficially more
attractive but in fact are likely to fail.
</t>

<t>
While we've described "frozen" here as a separate mechanism for
expository purposes, in fact it is an integral part of ICE and the ICE
prioritization algorithm automatically ensures that the right
candidates are unfrozen and checked in the right order. However, if
the ICE usage does not utilize multiple components or media streams,
it does not need to implement this algorithm.
</t>

</section>

<section title="Security for Checks">

<t>
Because ICE is used to discover which addresses can be used to send
media between two agents, it is important to ensure that the process
cannot be hijacked to send media to the wrong location. Each STUN
connectivity check is covered by a message authentication code (MAC)
computed using a key exchanged in the signaling channel. This MAC
provides message integrity and data origin authentication, thus
stopping an attacker from forging or modifying connectivity check
messages. Furthermore, if for example a SIP <xref target="RFC3261"/>
caller is using ICE, and their call forks, the ICE exchanges happen
independently with each forked recipient. In such a case, the keys
exchanged in the signaling help associate each ICE exchange with each
forked recipient.

</t>

</section>

<section title="Concluding ICE">

<t>
ICE checks are performed in a specific sequence, so that high-priority
candidate pairs are checked first, followed by lower-priority
ones. One way to conclude ICE is to declare victory as soon as a check
for each component of each media stream completes
successfully. Indeed, this is a reasonable algorithm, and details for
it are provided below. However, it is possible that a packet loss will
cause a higher-priority check to take longer to complete.  In that
case, allowing ICE to run a little longer might produce better
results. More fundamentally, however, the prioritization defined by
this specification may not yield "optimal" results. As an example, if
the aim is to select low-latency media paths, usage of a relay is a
hint that latencies may be higher, but it is nothing more than a
hint. An actual round-trip time (RTT) measurement could be made, and
it might demonstrate that a pair with lower priority is actually
better than one with higher priority.
</t>

<t>
Consequently, ICE assigns one of the agents in the role of the
CONTROLLING AGENT, and the other of the CONTROLLED AGENT. The
controlling agent nominates a candidate pair to be used for media.
</t>

<t>
When nominating, the controlling agent selects a candidate pair and
sends a STUN request on the selected pair with a flag set to indicate
to the controlled peer that it has nominated the selected pair.
This is shown in <xref target="fig-regular-select"/>.
</t>

<figure title="Nomination"
anchor="fig-regular-select" align="center"><artwork>
<![CDATA[
L                        R
-                        -
STUN request ->             \  L's
          <- STUN response  /  check

           <- STUN request  \  R's
STUN response ->            /  check

STUN request + flag ->      \  L's
          <- STUN response  /  check

]]></artwork></figure>

<t>
Once the STUN transaction with the flag completes, the controlled
agent will select the nominated candidate pair and send media using it.
</t>

<t>
ICE can be restarted according to the mechanism defined by the using
protocol.
</t>

</section>

<section title="Lite Implementations">

<t>
In order for ICE to work, both agents need to support it.
However, certain agents will always be connected to the public
Internet and have a public IP address at which it can receive packets
from any correspondent. To make it easier for these devices to support
ICE, ICE defines a special type of implementation called LITE (in
contrast to the normal FULL implementation). 
Lite agents only uses host candidates 
and does not generate connectivity checks or run
the state machines, though they need to be able to respond to
connectivity checks. When a lite implementation connects with a full
implementation, the full agent takes the role of the controlling
agent, and the lite agent takes on the controlled role. When two lite
implementations connect, no checks are sent.
</t>

<t>For guidance on when a
lite implementation is appropriate, see the discussion in <xref
target="sec-liteandfull"/>.
</t>

<t>
It is important to note that the lite implementation was added to this
specification to provide a stepping stone to full implementation. Even
for devices that are always connected to the public Internet, a full
implementation is preferable if achievable.
</t>

</section>

<section title="Usages of ICE">

<t>This document specifies generic use of ICE with protocols that
provide means to exchange candidate information between the ICE peers.
The specific details of (i.e how to encode candidate information and
the actual candidate exchange process) for different protocols using
ICE are described in separate usage documents. One possible way the
agents can exchange the candidate information is to use <xref
target="RFC3264"/> based Offer/Answer semantics as part of the SIP
<xref target="RFC3261"/> protocol <xref
target="I-D.ietf-mmusic-ice-sip-sdp"/>.
</t>
</section>
</section>

<section title="Terminology">

<t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as described in
<xref target="RFC2119">RFC 2119</xref>.  </t>

<t>
Readers should be familiar with the terminology defined in the STUN <xref
target="RFC5389"/>, and NAT Behavioral requirements
for UDP <xref target="RFC4787"/>.
</t>

<t>
This specification makes use of the following additional terminology:
</t>

<t><list style="hanging">

<t hangText="ICE Agent:">
An ICE agent is the protocol implementation involved in the
ICE candidate exchange.</t>

<t hangText= "Initiating Peer, Initiating Agent, Initiator:">
The initiating agent is an ICE agent that initiates the ICE candidate exchange
process. </t>

<t hangText="Responding Peer, Responding Agent, Responder:">
The receiving agent is ICE agent that receives
and responds to the candidate exchange process initiated by the
initiating agent. </t>

<t hangText="ICE Candidate Exchange, Candidate Exchange:">
The process where the ICE agents exchange information (e.g.,
candidates and passwords) that is needed to perform ICE.  <xref
target="RFC3264"/> Offer/Answer with SDP encoding is one example of a
protocol that can be used for exchanging the candidate
information. </t>

<t hangText="Peer:">
From the perspective of one of the agents in a session, its peer is
the other agent.</t>

<t hangText="Transport Address:"> The combination of an IP address and
transport protocol (such as UDP or TCP) port.</t>

<t hangText="Media, Media Stream, Media Session:"> When ICE is used to
setup multimedia sessions, the media is usually transported over RTP,
and a media stream composes of a stream of RTP packets. When ICE is
used with other than multimedia sessions, the terms "media", "media
stream", and "media session" are still used in this specification to
refer to the IP data packets that are exchanged between the peers on
the path created and tested with ICE. </t>

<t hangText="Candidate, Candidate Information:"> A transport address
that is a potential point of contact for receipt of media. Candidates
also have properties -- their type (server reflexive, relayed, or
host), priority, foundation, and base.
</t>

<t hangText="Component:"> A component is a piece of a media stream
requiring a single transport address; a media stream may require
multiple components, each of which has to work for the media stream as
a whole to work.</t>

<t hangText="Host Candidate:"> A candidate obtained by binding to a
port.
</t>

<t hangText="Server Reflexive Candidate:"> A candidate whose IP
address and port are a binding allocated by a NAT for an agent when it
sent a packet through the NAT to a server, such as a STUN server.
</t>

<t hangText="Peer Reflexive Candidate:"> A candidate whose IP
address and port are a binding allocated by a NAT for an agent when it
sent a packet through the NAT to its peer.
</t>

<t hangText="Relayed Candidate:"> A candidate obtained from a relay
server, such as a TURN server, which relays packets.
</t>

<t hangText="Base:"> The transport address that an agent sends from
for a particular candidate. For host, server reflexive and peer reflexive
candidates the base is the same as the host candidate. For relayed
candidates the base is the same as the relayed candidate.
</t>

<t hangText="Foundation:"> An arbitrary string used to group similar
candidates and control candidates freezing.
</t>

<t hangText="Local Candidate:">A candidate that an agent has obtained
and may send it its peer.
</t>

<t hangText="Remote Candidate:">A candidate that an agent received
from its peer.
</t>

<t hangText="Default Destination/Candidate:"> The default destination
for a component of a media stream is the transport address that would
be used by an agent that is not ICE-aware.  A default candidate for a
component is one whose transport address matches the default
destination for that component.
</t>

<t hangText="Candidate Pair:"> The pair of a local candidate
and a remote candidate.
</t>

<t hangText="Check, Connectivity Check, STUN Check:"> A STUN Binding
request for the purposes of verifying connectivity. A
check is sent from the base of the local candidate 
to the remote candidate of a candidate pair.
</t>

<t hangText="Check List:"> An ordered set of candidate pairs that an
agent will use to generate checks.
</t>

<t hangText="Ordinary Check:"> A connectivity check generated by an
agent as a consequence of a timer that fires periodically, instructing
it to send a check.
</t>

<t hangText="Triggered Check:"> A connectivity check generated as a
consequence of the receipt of a connectivity check from the peer.
</t>

<t hangText="Valid List:"> An ordered set of candidate pairs for a
media stream that have been validated by a successful STUN
transaction.
</t>

<t hangText="Check List Set:"> The ordered list of all check lists.
The order is determined by each ICE usage.
</t>


<t hangText="Full Implementation:"> An ICE implementation that
performs the complete set of functionality defined by this
specification.
</t>

<t hangText="Lite Implementation:"> An ICE implementation that
performs a limited set of functionality defined by this specification.
In particular, it only uses host candidates and does not send
connectivity checks.
</t>

<t hangText="Controlling Agent:"> The ICE agent that nominates a
candidate pair.
</t>

<t hangText="Controlled Agent:"> The ICE agent that does not nominate a
candidate pair.
</t>

<t hangText="Nomination, Regular Nomination:"> The process of the
controlling agent indicating to the controlled agent which candidate
pair the controlled agent should use to send media.
</t>

<t hangText="Nominated:"> If a valid candidate pair has its nominated
flag set, it means that it may be selected by ICE for sending and
receiving media.
</t>

<t hangText="Selected Pair, Selected Candidate Pair:"> The candidate
pair selected by an ICE agent for sending media.
</t>

<t hangText="Using Protocol, ICE Usage:"> The protocol that uses ICE
for NAT traversal. A usage specification defines the protocol-specific
details on how the procedures defined here are applied to that
protocol. </t>

</list></t>

</section>


<section anchor="sec-gathering_exchange" title="ICE Candidate Gathering and Exchange">

<t>
As part of ICE processing, both the initiating and responding agents
exchange encoded candidate information as defined by the Usage
Protocol (ICE Usage). Specifics of the encoding mechanism and the
semantics of candidate information exchange is out of scope of this
specification.
</t>

<t>
However at a higher level, the diagram below shows the how ICE agents
exchange of their respective candidate(s) information.
</t>

<figure title="Candidate Gathering and Exchange Sequence"
anchor="fig:basic-cand-exchange" align="left">
<artwork>
<![CDATA[
          Initiating                      Responding
            Agent                           Agent
            (I)                             (R)
Gather,      |                               |
prioritize,  |                               |
eliminate    |                               |
redundant    |                               |
candidates,  |                               |
Encode       |                               |
candidates   |                               |
             |   I's Candidate Information   |
             |------------------------------>|
             |                               | Gather,
             |                               | prioritize,
             |                               | eliminate
             |                               | redundant
             |                               | candidates,
             |                               | Encode
             |                               | candidates
             |   R's Candidate Information   |
             |<------------------------------|
             |                               |
]]></artwork></figure>
<t>
As shown, the agents involved in the candidate exchange perform (1)
candidate gathering, (2) candidate prioritization, (3) redundant 
candidate elimination, (4) (possibly) default candidate selection, and
(5) sending of the candidates to the peer. All
but the last of these five steps differ for full and lite
implementations.
</t>
<t>
</t>

<section anchor="sec-full-impl-reqs" title="Procedures for Full Implementation">


<section anchor="sec-gathering" title="Gathering Candidates">

<t>
Four types of candidates are gathered by the ICE agent according to
this specification: host, server reflexive, peer reflexive, and relayed.
</t>

<section title="Host Candidates">

<t> Host candidates are obtained by binding to ports on a IP address
attached to an interface (physical or virtual, including VPN
interfaces) on the host.
</t>

<t>For each component of each media stream the agent wishes to use,
the agent SHOULD gather a candidate on each IP address that the host
has, with the exceptions listed below.</t>

<t> Each component has an ID assigned to it, called the component ID.
For RTP-based media streams, unless both RTP and RTCP are multiplexed
in the same UDP port (RTP/RTCP multiplexing), the RTP itself has a
component ID of 1, and RTCP a component ID of 2. In case of RTP/RTCP
multiplexing, a component ID of 1 is used for both RTP and RTCP.</t>

<t>When candidates are obtained, unless the agent knows for sure that
RTP/RTCP multiplexing will be used (i.e. the agent knows that the
other agent also supports, and is willing to use, RTP/RTCP
multiplexing), or unless the agent only supports RTP/RTCP
multiplexing, the agent MUST obtain a separate candidate for RTCP. If
an agent has obtained a candidate for RTCP, and ends up using RTP/RTCP
multiplexing, the agent does not need to perform connectivity checks
on the RTCP candidate.  Absence of a component ID 2 as such does not
imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is
not used. </t>

<t> The host candidates are gathered from all IP addresses with the
following exceptions:

  <list style="symbols">

    <t> Addresses from a loopback interface MUST NOT be included in
    the candidate addresses. </t>

    <t> Deprecated IPv4-compatible IPv6 addresses <xref
    target="RFC4291"/> and IPv6 site-local unicast addresses <xref
    target="RFC3879"/> MUST NOT be included in the address
    candidates. </t>

    <t> IPv4-mapped IPv6 addresses SHOULD NOT be included in the
    address candidates unless the application using ICE does not
    support IPv4 (i.e., is an IPv6-only application <xref
    target="RFC4038"/>). </t>

    <t> If one or more host candidates corresponding to an IPv6
    address generated using a mechanism that prevents location
    tracking <xref target="RFC7721"/> are
    gathered, host candidates corresponding to IPv6 addresses that do
    allow location tracking, that are configured on the same
    interface, and are part of the same network prefix MUST NOT be
    gathered; and host candidates corresponding to IPv6 link-local
    addresses MUST NOT be gathered.</t>
  </list>

</t>

</section>

<section title="Server Reflexive and Relayed Candidates">

<t>
An agent SHOULD gather server reflexive and relayed candidates.
</t>

<t>This specification only considers usage of a single STUN or TURN
server. When there are multiple choices for that single STUN or TURN
server, an agent SHOULD use a single STUN or
TURN server for all candidates for a
particular session to improve the performance of ICE.
</t>

<t>
An agent MUST support the backwards compatibility mode for the Binding
request defined in <xref target="RFC5389"/> and MUST ignore any
ALTERNATE-SERVER attribute in a STUN Binding response.
</t>

<t>
The agent SHOULD NOT generate transactions
more frequently than one every Ta milliseconds. See <xref
target="sec-ta"/> for guidance on how to set Ta and the STUN
retransmit timer, RTO.
</t>

<t>A successful Allocate response will provide the agent with a server
reflexive candidate and a relayed candidate. If the Allocate request
is rejected because the server lacks resources to fulfill it, the
agent SHOULD instead send a Binding request to obtain a server
reflexive candidate. A Binding response will provide the agent with
only a a server reflexive candidate. 
</t>

<t>
If an IPv6-only agent is in a network that utilizes NAT64 <xref
target="RFC6146"/> and DNS64 <xref target="RFC6147"/> technologies, it
may also gather IPv4 server reflexive and/or relayed candidates from
IPv4-only STUN or TURN servers.  IPv6-only agents SHOULD also utilize
IPv6 prefix discovery <xref target="RFC7050"/> to discover the IPv6
prefix used by NAT64 (if any) and generate server reflexive candidates
for each IPv6-only interface accordingly.  The NAT64 server reflexive
candidates are prioritized like IPv4 server reflexive candidates.
</t>

</section>

<section anchor="sec-computing-foundations" title="Computing Foundations">

<t>
The agent assigns each candidate a foundation.  Two candidates MUST
have the same foundation when all of the following are true:
</t>

<t><list style="symbols">

<t>They have the same type (host, relayed,
server reflexive, or peer reflexive).</t>

<t>Their bases have the
same IP address (the ports can be different).</t>

<t>For reflexive and relayed candidates, the STUN or TURN servers used
to obtain them have the same IP address.
</t>

<t>They were obtained using the same transport protocol (TCP, UDP).
</t>

</list></t>

</section>

<section title="Keeping Candidates Alive">

<t>
Once server reflexive and relayed candidates are gathered, they MUST
be kept alive until ICE processing has completed, as described in
<xref target="sec-freeing"/>. For server reflexive candidates learned
through a Binding request, the bindings MUST be kept alive by
additional Binding requests to the server. Refreshes for allocations
are done using the Refresh transaction, as described in <xref
target="RFC5766"/>. The Refresh requests will also refresh the server
reflexive candidate.
</t>

</section>

<!-- end gathering -->
</section>

<section anchor="sec-prioritizing" title="Prioritizing Candidates">
<t>
The prioritization process results in the assignment of a priority to
each candidate. Each candidate MUST have a unique
priority (unique in the scope of a component of a media stream in a session)
that MUST be a positive integer between 1 and (2**31 - 1).
This priority will be used by ICE to determine the order of the
connectivity checks and the relative preference for candidates.
</t>

<t>
An agent SHOULD compute this priority using the formula in <xref
target="sec-rec-form"/> and choose its parameters using the guidelines
in <xref target="sec-guidelines"/>.  If an agent elects to use a
different formula, ICE may take longer to converge since both agents
will not be coordinated in their checks.
</t>


<section anchor="sec-rec-form" title="Recommended Formula">

<t>The recommended forumla combines a preference for the candidate
type (server reflexive, peer reflexive, relayed, and host), a
preference for IP address fro which the candidate was obtained, and
component ID using the following formula:
</t>

<figure><artwork>
<![CDATA[
priority = (2^24)*(type preference) +
           (2^8)*(IP address preference) +
           (2^0)*(256 - component ID)

]]></artwork></figure>

<t>
The type preference MUST be an integer from 0 (lowest prefereence) to
126 (highest preference) inclusive and MUST be identical for all
candidates of the same type and MUST be different for candidates of
different types. The type preference for peer reflexive candidates
MUST be higher than that of server reflexive candidates.
</t>

<t>The local preference MUST be an integer from 0 (lowest preference) 
to 65535 (highest preference) inclusive. When there is only a single IP
address, this value SHOULD be set to 65535.  If there
are multiple candidates for a particular component for a particular
media stream that have the same type, the local preference MUST be
unique for each one. If an agent is dual-stack, the local preference
should be set according to the current best practice described in <xref
target="I-D.ietf-ice-dualstack-fairness"/>.</t>


<t>The component ID MUST be an integer between 1 and 256 inclusive.</t>


</section>

<section anchor="sec-guidelines" title="Guidelines for Choosing Type and Local Preferences">

<t>The RECOMMENDED values for type preferences are 126 for host
candidates, 110 for peer reflexivec andidates, 100 for server
reflexive candidates, and 0 for relayed candidates.</t>

<t>If an agent is multihomed and has multiple IP
addresses, the recommendations in <xref target=
"I-D.ietf-ice-dualstack-fairness"/> SHOULD be followed.</t>

<t>When choosing type preferences, agents may take into account
factors such as latency, packet loss, cost, network topology,
security, privacy, and others.</t>


</section>

<!-- end prioritization -->
</section>

<section anchor="sec-el-red" title="Eliminating Redundant Candidates">

<t>
Next, agents (initiating and responding) eliminate redundant
candidates. A candidate is redundant if and only if its transport
address and base equal those of another candidate.  The agent SHOULD
eliminate the redundant candidate with the lower priority.
</t>
</section>
<!-- end full implementation -->
</section>

<section anchor="sec-offer-lite" title="Lite Implementation Procedures">

<t>
Lite agents (initating and responding) only use host candidates.  It
is RECOMMENDED that lite agents use no more than one IPv4 host
candidate and one IPv6 host candidate.
</t>

<t>Component IDs, foundations, and priorities follow the sames rules
as for full agents.</t>

<t>
Lite agents SHOULD choose the candidate most likely to be used as the
default candidate.  For dual-stack hosts, the IPv4 candidate is
RECOMMENDED.
</t>

</section>

<section anchor="sec-encoding" title="Encoding the Candidate Information">

<t>Agents (initiating and responding) needs the following information
about candidates to be exchanged.  How this information is encoded or
exchanged is out of scope of this specification.  The using protocol
should provide a means for exchaning new, additional information in
the future, including per-candidate information.
</t>

<t><list style="hanging">

<t hangText="Username Fragment and Password:"> Values used to perform
 connectivity checks. </t>

<t hangText="Lite or Full: ">Whether the agent is a lite agent or full
agent. </t>

<t hangText="Connectivity check pacing value:">The pacing value for
connectivity checks that the agent wishes to use.  If the agent wishes
to use a value other than default, it MUST include this in the exchange. </t>

<t hangText="Extensions:">Extensions that the agent supports.</t>

<t hangText="Candidates: "> For each candidiate, the type, IP address,
transport protocol, transport protocol port, foundation, component ID,
priority, and related address.  The related address MAY be omitted or
set to invalid values if the agent does not want to reveal them.
</t>

</list></t>

<t>
Once an agent has sent its candidate information, it MUST be
prepared to receive both STUN and media packets on each candidate. As
discussed in <xref target="sec-send-media"/>, media packets can be
sent to a candidate prior to its appearance as the default destination
for media.
</t>

</section>

</section>

<section anchor="sec-candidate_proc" title="ICE Candidate Processing">

<t>
Once a full agent (initiating or responding) has gathered its
candidates and received candidates from its peer, it will form CHECK
LISTs and perform connectivity checks.  All agents (full and lite)
respond to connectivity checks.
</t>

<section anchor="sec-candidate_proc_full" title="Procedures for Full Implementation">


<section anchor="sec-role" title="Determining Role">

<t>
If both agents are full or both agents are lite, the initiating agent
MUST choose the controlling role and the responding agent MUST choose
the controlled role.  If one agent is full and the other lite, the
full agent MUST choose the controlling role and the lite agent MUST
choose the controlled role.
</t>

<t>
An agent MUST NOT change roles unless either a role conflict is
detected (procedures for which are defined in <xref
target="sec-role-conflict"/>) or a full agents changes to a
lite agent as part of an ICE restart.
</t>

<t>
An agent MUST be prepared for its peer to change roles as part of an
ICE restart. This can happen if the peer is compliant with an older
version of this specification.
</t>

</section>


<section anchor="sec-forming" title="Forming the Check Lists">

<t>
There is one check list for each media stream.  To form a check list,
an agent (initiaing and responding) forms candidate pairs, computes
pair priorities, orders pairs by priority, prunes pairs, removes
lower-priority pairs, and sets check list states. If candidates are
added to a check list (e.g, due to detection of peer reflexive
candidates), the agent will re-perform these steps for the updated
check list.
</t>
<section title="Check List State">
<t>Each check list has one of the following states:</t>
<t><list style="hanging">

<t hangText="Running:">The check list is neither Completed yet nor
Failed yet.  This means that at least one component of the check list
does not have a selected candidate pair and that no component of the
check list has candidate pairs that are all in the Failed state.
</t>

<t hangText="Completed:">The check list has a selected candidate pair
for each component of the media stream.
</t>

<t hangText="Failed:">The check list does not have a valid candidate
pair for each component of the media stream and all of the candidate
pairs in the check list are in either the Failed or Succeeded state.
In other words, at least one component of the check list has candidate
pairs that are all in the Failed state.
</t>

</list></t>
<t>Additionally, a check list with at least one pair in the waiting
state is called "active", while a check list with all pairs in the
frozen state is called "frozen".
</t>

</section>

<section title="Forming Candidate Pairs">

<t>
The agent pairs each local candidate with each remote candidate for
the same component of the same media stream with the same IP
address version and transport protocol.
</t>

<t>To reduce the number of candidate pairs and to avoid candidate
pairs that are highly unlikely to work, IPv6 link-local addresses
<xref target="RFC4291"/> MUST NOT be paired with other than link-local
addresses. </t>

<t>
<xref target="fig-check-model"/> shows the properties of and
relationships between transport addresses, candidates, candidate
pairs, and check lists.
</t>

<figure title="Conceptual Diagram of a Check List"
	anchor="fig-check-model" align="center"><artwork>
<![CDATA[
    +--------------------------------------------+
    |                                            |
    | +---------------------+                    |
    | |+----+ +----+ +----+ |   +Type            |
    | || IP | |Port| |Tran| |   +Priority        |
    | ||Addr| |    | |    | |   +Foundation      |
    | |+----+ +----+ +----+ |   +Component ID    |
    | |      Transport      |   +Related Address |
    | |        Addr         |                    |
    | +---------------------+   +Base            |
    |             Candidate                      |
    +--------------------------------------------+
    *                                         *
    *    *************************************
    *    *
  +-------------------------------+
 .|                               |
  | Local     Remote              |
  | +----+    +----+   +default?  |
  | |Cand|    |Cand|   +valid?    |
  | +----+    +----+   +nominated?|
  |                    +State     |
  |                               |
  |                               |
  |          Candidate Pair       |
  +-------------------------------+
  *                              *
  *                  ************
  *                  *
  +------------------+
  |  Candidate Pair  |
  +------------------+
  +------------------+
  |  Candidate Pair  |
  +------------------+
  +------------------+
  |  Candidate Pair  |
  +------------------+


         Check
         List

]]></artwork></figure>


</section>

<section anchor="sec-comp-pair-prio" title="Computing Pair Priority and Ordering Pairs">

<t>
The agent computes a priority for each candidate pair. Let G be the
priority for the candidate provided by the controlling agent. Let D be
the priority for the candidate provided by the controlled agent. Let X
be 1 if G is greater than D, and 0 otherwise.  The priority for a pair
is computed as:
</t>

<t><list style="empty">
<t>
pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + X
</t>
</list></t>

<t>
The agent sorts each check list in decreasing order of candidate pair
priority. If two pairs have identical priority, the ordering amongst
them is arbitrary.
</t>

</section>

<section title="Pruning the Pairs">

<t>
The agent prunes each check list.  This is done by removing a
candidate pair if it is redundant with a higher priority candidate
pair in the same check list.  Two candidate pairs are redundant if
their local candidates have the same base and their remote candidates
are identical.
</t>
</section>

<section title="Removing lower-priority Pairs">

<t>
In order to limit the attacks described in <xref
target="sec-ice-hammer"/>, an agent MUST limit the total number of
candidate pairs across all check lists, and this limit MUST be
configurable. A default of 100 is RECOMMENDED.  This limit is enforced
by discarding the lower-priority candidate pairs until there are less
than limit.
</t>

</section>

<section title="Computing Candidate Pair States">

<t>
Each candidate pair in the check list has one of the following states:
</t>

<t><list style="hanging">
<t hangText="Frozen:"> A check has not been sent for this pair,
and a check can not be sent until the pair is unfrozen.
</t>

<t hangText="Waiting:"> A check has not been sent for this pair, but
the pair is not Frozen.
</t>

<t hangText="In-Progress:"> A check has been sent for this pair, but
has not completed.
</t>

<t hangText="Succeeded:"> A check has been sent for this pair, and has
completed with a successful result.
</t>

<t hangText="Failed:"> A check has been sent for this pair, and has
completed with a failure result (a failure response or timeout).
</t>
</list></t>

<t>
Pairs move between states as shown in <xref target="fig-state-fsm"/>.
</t>

<figure title="Pair State FSM" anchor="fig-state-fsm" align="center"><artwork>
<![CDATA[
   +-----------+
   |           |
   |           |
   |  Frozen   |
   |           |
   |           |
   +-----------+
         |
         |unfreeze
         |
         V
   +-----------+         +-----------+
   |           | send    |           |
   |           | check   |           |
   |  Waiting  |-------->|In-Progress|
   |           |         |           |
   |           |         |           |
   +-----------+         +-----------+
                               / |
                             //  |
                           //    |
                         //      |
                        /        |
                      //         |
            failure //           |success
                  //             |
                 /               |
               //                |
             //                  |
           //                    |
          V                      V
   +-----------+         +-----------+
   |           |         |           |
   |           |         |           |
   |   Failed  |         | Succeeded |
   |           |         |           |
   |           |         |           |
   +-----------+         +-----------+
]]></artwork></figure>

<t><list style="numbers">

<t>
The agent initially places all candidate pairs in the Frozen state.
</t>

<t>
For each foundation, the agent sets the state of exactly one candidate
pair to the Waiting state (unfreezing it).  The candidate pair to
unfreeze is choosen by finding the first candidate pair (ordered by
lowest component ID and then highest priority if component IDs are
equal) in the first check list (ordered by the check list set) that
has that foundation.
</t>

</list></t>

<t>NOTE: The procedures above are different from RFC5245, where only
candidate pairs in the first check list of were initially placed in
the Waiting state.  Now it applies to candidate pairs in the the first
check list which have that foundation, even if the first check list to
have that foundation is not the first check list in the check list set.
</t>

<t>
The table in <xref target="fig-state-initial"/> illustrates an example.
</t>

<figure title="Initial Pair State" anchor="fig-state-initial" align="center"><artwork>
<![CDATA[

Table legend:

Each row (m1, m2,...) represents a check list associated with a media
stream. m1 represents the first check list in the check list set.

Each column (f1, f2,...) represents a foundation. Every candidate pair
within a given column share the same foundation.

f-cp represents a candidate pair in the Frozen state.

w-cp represents a candidate pair in the Waiting state.

1. The agent sets all of the pairs in the check list set to the Frozen
state.

      f1    f2    f3    f4    f5
    -----------------------------
m1 | f-cp  f-cp  f-cp
   |
m2 | f-cp  f-cp  f-cp  f-cp
   |
m3 | f-cp                    f-cp


2. For each foundation, the candidate pair with the lowest component ID
is placed in the Waiting state, unless a candidate pair associated with
the same foundation has already been put in the Waiting state in one of
the other examined check lists in the check list set.

      f1    f2    f3    f4    f5
    -----------------------------
m1 | w-cp  w-cp  w-cp
   |
m2 | f-cp  f-cp  f-cp  w-cp
   |
m3 | f-cp                    w-cp


In the first check list (m1) the candidate pair for each foundation is
placed in the Waiting state, as no pairs for the same foundations have
yet been placed in the Waiting state.

In the second check list (m2) the candidate pair for foundation f4 is
placed in the Waiting state. The candidate pair for foundations f1, f2
and f3 are kept in the Frozen state, as candidate pairs for those
foundations have already been placed in the Waiting state (within check
list m1).

In the third check list (m3) the candidate pair for foundation f5 is
placed in the Waiting state. The candidate pair for foundation f1 is
kept in the Frozen state, as a candidate pair for that foundation have
already been placed in the Waiting state (within check list m1).

Once each check list have been processed, one candidate pair for each
foundation in the check list set has been placed in the Waiting state.

]]></artwork></figure>

</section>
</section>

<section anchor="sec-state" title="ICE State">
<t>
The ICE agent has a state determined by the state of the check
lists. The state is Completed if all check lists are Completed, Failed
if all check lists are Failed, and Running otherwise.
</t>
</section>

<section anchor="sec-periodic" title="Scheduling Checks">
<t>
When candidate pairs are unfrozen, the agent perfoms connectivity
checks.  Connectivity checks are govererned by a timer called Ta.  The
agent chooses a candidate pair and sends the first check by by sending
a STUN request from the base of the local candiditate to the remote
candidate following the procedures in <xref
target="sec-connectivity_check"/>.  Then every time Ta fires, it
chooses a candidate pair and sends a check.  After sending each check,
the agent sets the candidate pair state to In-Progress.
</t>

<t>The agent chooses a candidate pair by first choosing a check list
and second choosing a candidate pair within that check list.  If the
process of choosing a candidate pair within a check list results in no
candidate pair, the agent follows the same procedure again to choose a
different check list until a candidate pair is chosen.
</t>

<t>
The first time the agent chooses a check list, it chooses the first
check list (ordered by the check list set) that is in the Running
state.  Subsequent times, the agent chooses the next check list that
is in the Running state.  If there is no such check list in the
Running state, the agent chooses the first check list in the Running
state again, thus cycling through all the check lists in the Running
state repeatedly.
</t>

<t>The agent chooses a candidate pair within a check list by first
examining a FIFO queue of candidate pairs called the TRIGGERED CHECK
QUEUE. If the triggered check queue is not empty, the agent removes
the first pair from the queue and chooses that pair.  If the triggered
check queue is empty, the agent chooses the first candidate pair in
the Waiting state.
</t>

<t>
If there is no candidate pair in the Waiting state, the agent chooses
the first candidate pair in the check list which is in the Frozen
state and which has an inactive foundation.  An foundation is inactive
if none of the candidates (across all check lists) in the In-Progress
or Waiting states have that foundation.
</t>

<t>
If no such Frozen candidate pair exists, no candidate pair is chosen
for the check list, and the agent may choose another check list.
</t>

<t>An agent MAY terminate connectivity checks for specific checks
lists at any time.
</t>

</section>
<!-- end of full implementation -->
</section>

<section anchor="sec-candidate_proc_lite" title="Lite Implementation Procedures">

 <t>
 Because lite agents do not send connectivity checks, they not perform
 the steps necessary to to choose a candidate pair for sending a
 connectivity check.
 </t>

</section>

</section>


<section anchor="sec-connectivity_check" title="Performing Connectivity Checks">

<t>This section describes how connectivity checks are performed.
</t>
<t>An ICE agent MUST be compliant to to <xref target="RFC5389"/>. A full
implementation acts both as a STUN client and a STUN server, while a
lite implemenation only acts as a STUN server (as it does not generate
connectivity checks).
</t>

<section title="STUN Extensions">
<t>ICE extends STUN by defining new attributes: PRIORITY, USE-CANDIDATE,
ICE-CONTROLLED, and ICE-CONTROLLING. The new attributes are formally defined in
<xref target="sec-ice-newatts"/>. This section describes the usage of the
new attributes.
</t>
<t>The new attributes are only applicable to ICE connectivity checks.
</t>

<section title="PRIORITY">
<t>The priority attribute MUST be included in a Binding request and be
set to the value computed by the algorithm in <xref
target="sec-prioritizing"/> for the local candidate, but with the
candidate type preference of peer reflexive candidates.
</t>
</section>

<section title="USE-CANDIDATE">
<t>The controlling ICE agent MUST include the USE-CANDIDATE attribute in
order to nominate a candidate pair <xref target="sec-choose-favor"/>.
The controlled ICE agent MUST NOT include the USE-CANDIDATE attribute
in a Binding request.
</t>
</section>

<section anchor="sec-tie-client" title="ICE-CONTROLLED and ICE-CONTROLLING">
<t>The controlling ICE agent MUST include the ICE-CONTROLLED attribute in a Binding
request. The controlled ICE agent MUST include the ICE-CONTROLLING attribute in
a Binding request.
</t>
<t>The content of either attribute are used as tie-breaker values
when an ICE role conflict occurs <xref target="sec-role-conflict"/>.
</t>
</section>
</section>


<section anchor="sec-client" title="STUN Client Procedures">
<section anchor="sec-permissions" title="Creating Permissions for Relayed Candidates">
<t>The agent MUST create a permission before sending a check from a relayed local
candidate.  To create the permission, the agent
follows the procedures defined in <xref target="RFC5766"/>.  The
permission MUST be created towards the IP address of the remote
candidate.  It is RECOMMENDED that the agent defer creation of a TURN
channel until ICE completes, in which case permissions for
connectivity checks are normally created using a CreatePermission
request.  Once established, the agent MUST keep the permission active
until ICE concludes.
</t>
</section>

<section title="Forming Credentials">
<t>A connectivity check Binding request MUST utilize the STUN
short-term credential mechanism (i.e., the MESSAGE-INTEGRITY
attribute).
</t>
<t>The username for the credential is formed by concatenating the
username fragment provided by the peer with the username fragment of
the agent sending the request, separated by a colon (":").  Each
username fragment MUST contain at least 24 bits of randomness
</t>
<t>The password is equal to the password provided by the peer.  The
password MUST contain at least 128 bits of randomness.
</t>
<t>For example, consider the case where ICE agent L is the
Initiating agent and ICE agent R is the Responding agent. Agent L
included a username fragment of LFRAG for its candidates and a
password of LPASS. Agent R provided a username fragment of RFRAG and a
password of RPASS. A connectivity check from L to R utilizes the
username RFRAG:LFRAG and a password of RPASS. A connectivity check
from R to L utilizes the username LFRAG:RFRAG and a password of
LPASS. The responses utilize the same usernames and passwords as the
requests (note that the USERNAME attribute is not present in the
response).
</t>

<t>Support for backwards compatibility with RFC 3489 MUST NOT
be assumed when performing connectivity checks. The FINGERPRINT mechanism
MUST be used for connectivity checks.
</t>
</section>

<section title="DiffServ Treatment">
<t>If an ICE agent is using Diffserv Codepoint markings <xref
target="RFC2475"/> in its media packets, the agent SHOULD apply
those same markings to its connectivity checks.
</t>
</section>

<section anchor="sec-recv-response" title="Processing the Response">
<t>This section defines additional procedures for processing Binding responses
specific to ICE connectivity checks.
</t>
<t>When an agent receives a Binding response, it uses the transaction
ID <xref target="RFC5389"/> to find the corresponding Binding request
and candidate pair and then processes the Binding response according
to the following procedures:
</t>

<section title="Success">

<t>A connectivity check is successful if and only if the response is a
success and the request and response are symmetric.  They are
symmetric if and only if the source IP address and port of the
response are equal to the destination IP address and port to which the
request was sent, and the destination IP address and port of the
response are equal to the source IP address and port from which the
request was sent.
</t>

</section>

<section title="Failure">
    <section title="Unrecoverable STUN Response">
      <t>The agent SHOULD set the candidate pair state to Failed if
      the response is an unrecoverable error <xref target="RFC5389"/>)
      or if the transaction times out.
      </t>
    </section>

    <section title="ICMP Error">
      <t>The agent SHOULD set the candidate pair state to Failed if
      the Binding request generates an ICMP error.
      </t>
    </section>

    <section title="Non-Symmetric Transport Addresses">
      <t>The agent MUST set the candidate pair state to Failed if the
      request and response are not symmetric.  
      </t>
    </section>

    <t>NOTE: When the agent sets the candidate pair state to Failed as
    a result of a connectivity check error, the agent does not change
    the states of other candidate pairs.
    </t>
</section>

<section title="Role Conflict">
    <t>If the response is a 487 (Role Conflict) error, the agent MUST
    switch its role according the attributes in the request and add
    the candidate pair to the triggered check queue and set the pair
    state to Waiting. If the request included an ICE-CONTROLLED
    attribute the agent MUST switch to the controlling role.  If the
    request included an ICE-CONTROLLING attribute, the agent MUST
    switch to the controlled role.  The ICE agent MUST NOT change the
    tie-breaker value.
    </t>

    <t>
      A change in roles will require an agent to recompute pair
      priorities (<xref target="sec-comp-pair-prio"/>), since those
      priorities are a function of role. The change in role will also
      impact whether the agent is responsible for selecting nominated
      pairs and initiating exchange with updated candidate information
      upon conclusion of ICE.
    </t>
</section>

<section anchor="sec-learn-peer-client" title="Discovering Peer Reflexive Candidates">

<t>The agent MUST check the mapped address in the response. If
the transport address does not match any of the local candidates, the
mapped address represents a new peer reflexive candidate which is
added to the corresponding check list.  The type, base, priority, and
foundation are computed as follows.
</t>

<t><list style="symbols">
<t>The type is peer reflexive.</t>
<t>The base is local candidate of the candidate pair
from which the Binding request was sent.</t>
<t>The priority is the value of the PRIORITY attribute in
the Binding request.</t>
<t>The foundation is described in <xref target="sec-computing-foundations"/>.</t>
</list></t>

<t>The agent does not need to pair the peer reflexive
candidate with remote candidates, as a valid candiate pair will be
created due to the procedures in <xref target="sec-valid-cons"/>.
If an agent wishes to pair the peer reflexive candidate with
remote candidates other than the one in the valid pair that will
be generated, the agent MAY provide updated candidate information to
the peer that includes the peer reflexive candidate. This will cause
the peer reflexive candidate to be paired with all other remote candidates.
</t>
</section>

<section anchor="sec-valid-cons" title="Constructing a Valid Pair">
<t>The agent constructs a candidate pair whose local candidate equals the
mapped address of the response, and whose remote candidate equals the
destination address to which the request was sent. This is called a
valid pair.
</t>

<t>For each check list, the agent maintains a list of valid pairs.
This list is called the VALID LIST and is initially empty.  The valid
list tracks whether or not a valid pair in it has been nominated or
not, which means that valid pair SHOULD be used for sending media
unless the sending agent detects that the candidate pair does not work
This state is called the the Nominated Flag and is intially false.
</t>

<t>The agent adds a valid pair to a valid list as follows:
<list style="numbers">
<t>If the valid pair equals the pair that generated the check, the pair is added to
the valid list associated with the check list to which the pair belongs; or
</t>
<t>If the valid pair equals another pair in a check list, that pair is added
to the valid list associated with the check list of that pair. The pair that
generated the check is not added to a valid list; or
</t>
<t>If the valid pair is not in any check list, the agent computes the
priority for the pair based on the priority of each candidate, using
the algorithm in <xref target="sec-forming"/> and the pair is added to
the valid list. If the local candidate is peer reflexive, the
priority used in the algorithm for it is that of the PRIORITY
attribute from the Binding request that just completed.  If the remote
candidate's priority is not known from the exchanged candidate
information, the priority used in the algorithm for it is that of the
PRIORITY attribute in the Binding request that triggered the check
that just completed.  Otherwise, the priorities used come from the
exchanged candidate information.
</t>
</list></t>

</section>


<section title="Updating Candidate Pair States">
<t>The agent sets the states of both the candidate pair that generated
the check and the constructed valid pair (which may be different) to
Succeeded.
</t>
<t>The agent MUST set the states for all other Frozen candidate pairs
in all check lists with the same foundation to Waiting.
</t>
</section>

<section title="Updating the Nominated Flag">

<t>If the request had included a USE-CANDIDATE attribute in the
Binding request, the controlling agent sets the Nominated Flag of the
valid pair to true.  This concludes the ICE processing for this media
stream; see <xref target="sec-conclude"/>.
</t>

<t>If the response was the result of a triggered check that was sent
in response to a request that itself had the USE-CANDIDATE attribute,
the controlled agent may now set the Nominated Flag for the pair
learned from the original request.  This case is described in <xref
target="sec-up-fav"/>.
</t>

<t>An ICE agent MUST NOT select a candidate pair until it has sent a
Binding request and received the corresponding Binding response
associated with the candidate pair.
</t>

</section>


<!-- end success cases -->
</section>

<section title="Check List State Updates">
<t>
The completion of a check (either successful or failed) may require
updating check list states according to the definitions in <xref
target="sec-forming"/>.
</t>
</section>

<!-- end processing response -->
</section>


<section anchor="sec-serverproc" title="STUN Server Procedures">

<t>
An agent (lite or full) MUST be prepared to receive Binding requests
on the base of each candidate it included in its most recent candidate
exchange.
</t>

<t>
A Binding response MUST utilize the STUN short-term credential
mechanism (i.e., the MESSAGE-INTEGRITY attribute).  The username is
considered valid if and only if it consists of two values separated by
a colon, where the first value is equal to the username fragment
generated by the agent in a candidate exchange for a session
in-progress.  An agent MUST NOT utilize the ALTERNATE-SERVER
mechanism, and MUST NOT support the backwards-compatibility mechanisms
of RFC 3489. It MUST utilize the FINGERPRINT mechanism.
</t>

<t>
If the initiating agent receives Binding requests before receiving
candidates, it MUST generate responses, including computation of the
mapped address as described in <xref
target="sec-compute-mapped"/>). 
</t>

<t>
If the agent is using Diffserv Codepoint markings <xref
target="RFC2475"/> in its media packets, it SHOULD apply the same
markings to Binding responses. The same would apply to any layer 2
markings the endpoint might be applying to media packets.
</t>

<section anchor="sec-add-server-full" title="Additional Procedures for Full Implementations">

<t>This subsection defines the additional server procedures applicable
to full implementations.
</t>

<section anchor="sec-role-conflict" title="Detecting and Repairing Role Conflicts">
<t>
In certain usages of ICE, both agents may end up choosing the same
role, resulting in a role conflict.  The section describes a mechanism
for detetecing and repairing role conflicts.  The usage document
MUST specify whether this mechanism is needed.
</t>

<t>
An agent MUST examine the Binding request for either the
ICE-CONTROLLING or ICE-CONTROLLED attribute. It MUST follow these
procedures:
<list style="symbols">
<t>
If neither ICE-CONTROLLING nor ICE-CONTROLLED is present in the
request, the peer agent may have implemented a previous version of
this specification. There may be a conflict, but it cannot be
detected.
</t>

<t>
If the agent is in the controlling role, and the ICE-CONTROLLING
attribute is present in the request:
<list style="symbols">
<t>
If the agent's tie-breaker value is larger than or equal to the contents
of the ICE-CONTROLLING attribute, the agent generates a Binding error
response and includes an ERROR-CODE attribute with a value of 487
(Role Conflict) but retains its role.
</t>
<t>
If the agent's tie-breaker value is less than the contents of the
ICE-CONTROLLING attribute, the agent switches to the controlled
role.
</t>
</list>
</t>

<t>
If the agent is in the controlled role, and the ICE-CONTROLLED
attribute is present in the request:
<list style="symbols">
<t>
If the agent's tie-breaker value is larger than or equal to the contents
of the ICE-CONTROLLED attribute, the agent switches to the
controlling role.
</t>
<t>
If the agent's tie-breaker value is less than the contents of the
ICE-CONTROLLED attribute, the agent generates a Binding error response
and includes an ERROR-CODE attribute with a value of 487 (Role
Conflict) but retains its role.
</t>
</list>
</t>

</list></t>

<t>
A change in roles will require an agent to recompute pair priorities
(<xref target="sec-comp-pair-prio"/>), since those priorities are a
function of role. The change in role will also impact whether the
agent is responsible for selecting nominated pairs and initiating
exchange with updated candidate information upon conclusion of ICE.
</t>

<t>
The remaining sections in <xref target="sec-add-server-full"/> are
followed if the agent generated a successful response to the Binding
request, even if the agent changed roles.
</t>

</section>


<section anchor="sec-compute-mapped" title="Computing Mapped Address">

<t>
For requests received on a relayed candidate, the source
transport address used for STUN processing (namely, generation of the
XOR-MAPPED-ADDRESS attribute) is the transport address as seen by the
TURN server. That source transport address will be present in the
XOR-PEER-ADDRESS attribute of a Data Indication message, if the
Binding request was delivered through a Data Indication. If the
Binding request was delivered through a ChannelData message, the
source transport address is the one that was bound to the channel.
</t>

</section>

<section anchor="sec-learn-peer-server" title="Learning Peer Reflexive Candidates">

<t>
If the source transport address of the request does not match any
existing remote candidates, it represents a new peer reflexive remote
candidate. This candidate is constructed as follows:

<list style="symbols">
<t>The type is peer reflexive.</t>
<t>The priority is the value of the PRIORITY attribute in
the Binding request.</t>
<t>The component ID is the component ID of
the local candidate to which the request was sent.
<t>The foundation is an arbitrary value,
different from the foundations of all other remote candidates. If any
subsequent candidate exchanges contain this peer reflexive
candidate, it will signal the actual foundation for the
candidate.</t>
</t>
</list>
</t>

<t>This candidate is added to the list of remote candidates. However,
the agent does not pair this candidate with any local candidates.
</t>

</section>

<section anchor="sec-triggered" title="Triggered Checks">

<t>
If the check list does not already contain a candidate pair with a
local candidate equal to the transport address on which the Binding
request was received and a remote candidate equal to the source
transport address where the request came from, the agent MUST
insert such a candidate pair into the check list (based on its
priority, and with a state of Waiting).  It then uses the candidate pair,
whether it existed previously or was just inserted, according the
following rules:

<list style="symbols">
  <t>If the pair state is Waiting or Frozen, the agent adds the pair to the
  triggered check queue if it is not already in it.
  </t>

  <t>If the pair state is Failed, the agent adds the pair to the the
  triggered check queue and sets the state of the pair to Waiting.
  </t>

  <t>If the pair state is In-Progress, the agent cancels the in-progress
  transaction (meaning the agent will not retransmit the request, will
  not treat the lack of response to be a failure, and will wait the
  duration of the transaction timeout for a response) and adds the
  pair to the the triggered check queue and sets the state of the pair
  to Waiting.
  </t>

  <t>If the state is Succeeded, nothing further is done. </t>
</list>
</t>

<t>
When a triggered check is sent, it is constructed and processed as
described in <xref
target="sec-send-check"/>target="sec-connectivity_check"/>.  The
username fragment for the remote candidate is the part after the colon
of the USERNAME attribute in the Binding request that was just
received.  The password is known from the candidates received from the
peer corresponding to the username fragment.
</t>

<!-- end triggered checks -->
</section>

<section anchor="sec-up-fav" title="Updating the Nominated Flag">

<t>
After a controlled agent receives a Binding request with the
USE-CANDIDATE attribute on a candidate pair and a valid pair has been
constructed for that candidate pair, the controlled agent MUST set the
Nominated Flag of the valid pair to true.  Either event may happen
first, but the agent does not set the flag until both have
occurred.  This may end ICE processing for this media stream; see
<xref target="sec-conclude"/>.
</t>

</section>

<!-- end full implementation requirements -->
</section>

<section title="Additional Procedures for Lite Implementations">

<t>
If a lite agent receives a Binding request with the USE-CANDIDATE
attribute, the agent constructs a valid candidate pair with local
candidate equal to the transport address on which the request was
received, and remote candidate equal to the source transport address
of the request that was received and adds it to the valid list (if it
is not already in the valid list) and sets the Nominated Flag to true.
</t>

</section>


<!-- end server procedures -->
</section>


<!-- end connectivity checks -->
</section>

<section anchor="sec-conclude" title="Concluding ICE Processing">

<t>This section describes how an agent completes ICE.
</t>

<section anchor="sec-conclude-full" title="Procedures for Full Implementations">

<t>
Concluding ICE involves nominating pairs by the controlling agent and
updating of state machinery.
</t>

<section anchor="sec-choose-favor" title="Nominating Pairs">

<t>This section applies within the context of a single component of a
single media stream.</t>

<t>The controlling agent stops connectivity checks when some stopping
criterion is met (outside the scope of this document). It then selects
a valid candidate pair based on some selection criterion (outside the
scope of this document).  It then sends a connectivity check with the
USE-CANDIDATE attribute on the selected candidate pair by enqueuing
the selected candidate pair in the triggered check queue.  The
controlling agent MUST NOT nominate more than one candidate pair.
</t>

<t>The controlled agent SHOULD select the nominated candidate
pair. But before a candidate pair has been selected, the controlled
agent may send media on any valid candidate pair.
</t>

<t>After selecting a candidate pair, the agent MUST remove all Waiting
and Frozen pairs from the check list and triggered check queue.
The agent SHOULD cease retransmissions of checks from In-Progress
candidate pairs thar are of lower priority than the selected candidate pair.
</t>

<t>If a check list is Completed (for all components of the check
list), the agent MUST continue to respond to any checks it may
still receive for that media stream, perform triggered checks if
required by the processing of <xref target="sec-serverproc"/>, and
continue retransmitting any In-Progress checks for that check list.
</t>

<t>
A controlling agent that does not support this specification (i.e. it
is implemented according to RFC 5245) might nominate more than one
candidate pair.  This was referred to as aggressive nomination in RFC
5245. The usage of the 'ice2' ice option by endpoints supporting this
specifcation should prevent such controlling agents from using
aggressive nomination.  But if more than one candidate pair is
nominated by the controlling agent, the controlled agent SHOULD select
the candidate pair with the highest priority.
</t>

</section>

<section anchor="sec-conc-state" title="Updating States">

<t>If some of the the check lists are Completed and some are Failed
and all are either Completed or Failed, remove the failed media
streams and send an updated candidate list to the peer.  All checks
lists are now Completed.</t>

<t>If all check lists are Completed, the agent is Completed. </t>

<t>If all check lists are Failed, the agent is Failed and SHOULD NOT
restart ICE. </t>

</section>

</section>

<section anchor="sec-lite-conclude" title="Procedures for Lite Implementations">

<t>
When ICE concludes, a lite agent can free host candidates that were
not used by ICE, as described in <xref target="sec-freeing"/>.
</t>

<t>
If the peer is a full agent, the lite agent selects a candidate pair
when the full agent nominates it.  When the lite agent has selected a
candidate pair for all components of all media streams, it is
Completed.
</t>

<t>
If the peer is a lite agent, the agent pairs local candidates with
remote candidates that are for the same media stream and have the same
component, transport protocol, and IP address family.  For each
component of each media stream, if there is only one canidate pair,
that pair is added to the valid list.  If there is more than one pair,
it is RECOMMENDED that an agent follow the procedures of RFC 6724
<xref target="RFC6724"/> to select a pair and add it to the valid
list.
</t>

<t>If all of the components for all media streams had one pair, the
state of ICE processing is Completed.  Otherwise, the controlling
agent MUST send an updated candidate list to reconcile different
agents selecting different candidate pairs.  ICE processing is
complete after and only after the updated canddiate exchange is
complete.
</t>

<!-- procedures for lite -->
</section>

<section anchor="sec-freeing" title="Freeing Candidates">

<section title="Full Implementation Procedures">

<t>
A full agent SHOULD NOT stop sending checks and responses from a
candidate until three seconds after all media streams using that
candidate are Completed, after which the agent MAY free the candidate
and stop sending checks and resposnes from it.  The three-second delay
handles cases when aggressive nomination is used, and the selected
pairs can quickly change after ICE has completed.
</t>

</section>

<section title="Lite Implementation Procedures">

<t>
A lite agent SHOULD NOT stop sending checks and responses from a
candidate until after all media streams using that candidate are
Completed, after which the agent MAY free the candidate and stop
sending checks and resposnes from it.
</t>

</section>

<!-- freeing -->
</section>

<!-- concluding -->
</section>


<section anchor="sec-restart" title="ICE Restarts">
<t>
An agent MAY restart ICE for existing media streams.  An ICE restart
causes all previous state of the media streams, excluding the roles of
the agents to be flushed.  The only difference between an ICE restart
and a brand new media session is that during the restart media can
continue to be sent, and that a new media session always requires the
roles to be determined.
</t>

<t>If an agent wants to change the destinations of media streams, it
MAY restart ICE to do so.</t>

<t>If an agent want to change its implmentation level, it MAY restart
ICE to do so.</t>

<t>
To restart ICE, an agent MUST change both the password and the
username fragment for the media stream(s) being restarted.  The new
candidate set MAY include some, none, or all of the previous
candidates.
</t>

<t>
As described in <xref target="sec-role"/>, ICE agents MUST NOT
re-determine the roles as part as an ICE restart, unless certain
criteria that require the roles to be re-determined are fulfilled.
</t>

</section>



<section anchor="sec-ice-option" title="ICE Option">

<t>
This section defines a new ICE option, 'ice2'. The ICE option
indicates that the ICE agent that includes it a candidate exchange
is compliant to this specification. For example, the
ICE agent will not use the aggressive nomination procedure
defined in <xref target="RFC5245"/>.
</t>
<t>
An ICE agent compliant to this specification MUST inform the peer
about the compliance using the 'ice2' option.
</t>
<t>
NOTE: The encoding of the 'ice2' ICE option, and the message(s)
used to carry it to the peer, are protocol specific. The encoding
for the Session Description Protocol (SDP) <xref target="RFC4566"/>
is defined in <xref target="I-D.ietf-mmusic-ice-sip-sdp"/>.
</t>

</section>


<section anchor="sec-keepalives" title="Keepalives">

<t>
All agents MUST send keepalives to keep NAT bindings alive.  The
keepalives SHOULD be sent using a format that is supported by its
peer.
</t>

<t>
For each candidate pair that an agent is using to send media, if no
packet has been sent on that pair in the last Tr seconds, an agent
MUST send a keepalive on that pair.  Agents SHOULD use a Tr value of
15 seconds. Agents MUST NOT use a Tr value smaller than 15 seconds.
first. An agent MUST begin sending keepalives once a candidate pair is
selected or a candidate pair is used to send media, whichever happens
first.  An agent MUST stop sending keepalives once the session
terminates or the media stream is removed.
</t>

<t>
Full ICE agents MUST use STUN Binding Indications for keepalives <xref
target="RFC5389"/>. The Indication MUST NOT utilize any authentication
mechanism. It SHOULD contain the FINGERPRINT attribute to aid in
demultiplexing, but SHOULD NOT contain any other attributes. It is
used solely to keep the NAT bindings alive.  Though Binding
Indications are used for keepalives, an agent MUST also respond to
connectivity check as discussed in <xref target="RFC5389"/>.
</t>

<t>
</t>

</section>

<section title="Media Handling">

<section anchor="sec-send-media" title="Sending Media">


<t>
An agent MAY send media on any valid candidate pair before a candidate
pair is selected.
</t>

<t>
An agent SHOULD send media on the selected candidate pair after it is
selected, unless the agent detects that the selected candidate pair does not
work.
</t>

<t>
An agent sends media from the base of the local candidate to the
remote candidate. In the case of a local relayed candidate, media
forwarded through the base in the relay server.
</t>

<t>
If the local candidate is a relayed candidate, it is RECOMMENDED that
an agent creates a channel on the TURN server towards the remote
candidate.  This is done using the procedures for channel creation as
defined in Section 11 of <xref target="RFC5766"/>.
</t>

<t>
Unless an agent is able to produce a selected pair for all components
associated with a media stream, the agent MUST NOT continue
sending media for any component associated with that media stream.
</t>

</section>

<section anchor="sec-recv-media" title="Receiving Media">

<t>
Agents SHOULD be prepared to receive media on any of the candidates
provided in the most recent candidate exchange with the peer.
</t>

<t>
RFC 3550 <xref target="RFC3550"/> describes an algorithm in Section
8.2 for detecting synchronization source (SSRC) collisions and
loops. These algorithms are based, in part, on seeing different source
transport addresses with the same SSRC. However, when ICE is used,
such changes will sometimes occur as the media streams switch between
candidates. An agent will be able to determine that a media stream is
from the same peer as a consequence of the STUN exchange that proceeds
media transmission. Thus, if there is a change in source transport
address, but the media packets come from the same peer agent, this
SHOULD NOT be treated as an SSRC collision.
</t>


</section>

</section>


<section anchor="sec-futureproof" title="Extensibility Considerations">

<t>
ICE has an extension mechanism called "ICE options".  When an agent
supports an extension, or option, it MAY indicate support in the
candidate exchange.  If an agent does not support a given extension,
or option, it MUST NOT indicate support in the candidate exchange.
</t>

</section>

<section anchor="sec-ta" title="Setting Ta and RTO">

<section anchor="sec-ta-gen" title="General">

<t>
While an agent is gathering (<xref target="sec-gathering"/>) and
sending connectivity checks (<xref target="sec-connectivity_check"/>),
it triggers STUN transactions. These transactions are paced at a rate
indicated by Ta, and the retransmission interval for each transaction
is calculated based on the the retransmission timer for the STUN
transactions (RTO) <xref target="RFC5389"/>.
</t>

<t>
This section describes how the Ta and RTO values are computed.
</t>

<t>
The formulas below result in a behavior whereby an agent will send its first
packet for every single connectivity check before performing a
retransmit. This can be seen in the formulas for the RTO (which
represents the retransmit interval). Those formulas scale with N, the
number of checks to be performed. As a result of this, ICE maintains a
nicely constant rate, but becomes more sensitive to packet loss. The
loss of the first single packet for any connectivity check is likely
to cause that pair to take a long time to be validated, and instead, a
lower-priority check (but one for which there was no packet loss) is
much more likely to complete first. This results in ICE performing
sub-optimally, choosing lower-priority pairs over higher-priority
pairs. Implementors should be aware of this consequence, but still
should utilize the timer values described here.
</t>

</section>

<section anchor="sec-ta-ta" title="Ta">

<t>
Agents SHOULD use the default Ta value, 50 ms, but MAY use another
value based on the characteristics of the associated media.
</t>

<t>
If an agent wants to use a Ta value other than the default value, it
MUST indicate the proposed value to its peer during the candidate
exchange. Both agents MUST use the higher value of the proposed
values.  If an agent does not propose a value, the default value is
used for that agent when comparing which value is higher.
</t>

<t>
Regardless of the Ta value chosen by each agent, the combination of
all transactions from all agents (if a given implementation runs
several concurrent agents) MUST NOT be sent more often than once every
5ms (as though there were one global Ta value for pacing all agents).
</t>

<t>
This mechanism of a global minimum pacing interval of 5ms is not
generally applicable to transport protocols, but is applicable to ICE
based on the following reasoning.

<list style="symbols">
  <t>Start with the following rules which would be generally
  applicable to transport protocols:
  <list style="numbers">
    <t>Let MaxBytes be the maximum number of bytes allowed to be
    outstanding in the network at start-up, which SHOULD be 14600
    bytes per RFC 6928.</t>
    <t>Let HTO be the transaction timeout, which SHOULD be 2*RTT if
    RTT is known and 500ms otherwise.  This is based on the RTO for
    STUN messages from RFC 5389 and the the TCP initial RTO, which is
    1 sec  in RFC 6298.</t>
    <t>Let MinPacing be the minimum pacing interval between
    transactions, which SHOULD be 5ms.</t>
  </list>
  </t>
  <t>
    Observe that ICE agents typically do not know the RTT for STUN
    transactions (connectivity checks in particular), meaning that HTO
    will almost always be 500ms.
  </t>
  <t>
    Observe that a MinPacing of 5ms and HTO of 500ms gives at most 100
    packets/HTO, which for a typical connectivity check of less than 120
    bytes means a maximum of 12000 outstanding bytes in the network,
    which is less than the maximum expressed by rule 1.
  </t>
  <t>
    Thus, for ICE, the rule set reduces down to just the MinPacing
    rule, which is equivalant to having a global Ta value.
  </t>
</list>
</t>

<t>
NOTE: <xref target="sec-concheckbw"/> shows examples of required bandwidth,
using different Ta values.
</t>

</section>

<section anchor="sec-ta-rto" title="RTO">

<t>

While gathering, agents SHOULD calculate the RTO value using the
following formula:
</t>

<figure><artwork>

<![CDATA[
  RTO = MAX (500ms, Ta * (Num-Of-Pairs))


  Num-Of-Pairs: the number of pairs of candidates
  with STUN or TURN servers.

]]></artwork></figure>

<t>
For connectivity checks, agents SHOULD calculate the RTO value
using the following formula:
</t>

<figure><artwork>

<![CDATA[
  RTO = MAX (500ms, Ta*N * (Num-Waiting + Num-In-Progress))


  Num-Waiting: the number of checks in the check list in the
  Waiting state.

  Num-In-Progress: the number of checks in the In-Progress state.

  Note that the RTO will be different for each transaction as the
  number of checks in the Waiting and In-Progress states change.

]]></artwork></figure>

<t>
Agents MAY calculate the RTO value using other mechanisms than those
described above. Agents MUST NOT use a RTO value smaller than 500 ms.
</t>

</section>

<!-- end Ta and RTO -->
</section>

<section anchor="sec-example" title="Example">

<t>
The example is based on the simplified topology of <xref
target="fig-ex-topo"/>.
</t>

<figure title="Example Topology" anchor="fig-ex-topo"><artwork>
<![CDATA[
                         +-------+
                         |STUN   |
                         |Server |
                         +-------+
                             |
                  +---------------------+
                  |                     |
                  |      Internet       |
                  |                     |
                  +---------------------+
                    |                |
                    |                |
             +---------+             |
             |   NAT   |             |
             +---------+             |
                  |                  |
                  |                  |
               +-----+            +-----+
               |  L  |            |  R  |
               +-----+            +-----+
]]></artwork></figure>


<t> Two agents, L and R, are using ICE. Both are full ICE
implementations. Both agents have a single IPv4 address. For agent L, it
is 10.0.1.1 in private address space <xref target="RFC1918"/>, and for
agent R, 192.0.2.1 on the public Internet. Both are configured with
the same STUN server (shown in this example for simplicity, although
in practice the agents do not need to use the same STUN server), which
is listening for STUN Binding requests at an IP address of 192.0.2.2
and port 3478. TURN servers are not used in this example. Agent L is
behind a NAT, and agent R is on the public Internet. The NAT has an
endpoint independent mapping property and an address dependent
filtering property. The public side of the NAT has an IP address of
192.0.2.3.
</t>

<t> To facilitate understanding, transport addresses are listed using
variables that have mnemonic names. The format of the name is
entity-type-seqno, where entity refers to the entity whose IP address
the transport address is on, and is one of "L", "R", "STUN", or
"NAT". The type is either "PUB" for transport addresses that are
public, and "PRIV" for transport addresses that are private. Finally,
seq-no is a sequence number that is different for each transport
address of the same type on a particular entity. Each variable has an
IP address and port, denoted by varname.IP and varname.PORT,
respectively, where varname is the name of the variable. </t>

<t>The STUN server has advertised transport address STUN-PUB-1 (which
is 192.0.2.2:3478).
</t>

<t> In the call flow itself, STUN messages are annotated with several
attributes. The "S=" attribute indicates the source transport address
of the message. The "D=" attribute indicates the destination transport
address of the message. The "MA=" attribute is used in STUN Binding
response messages and refers to the mapped address. "USE-CAND" implies
the presence of the USE-CANDIDATE attribute.
</t>

<t>
The call flow examples omit STUN authentication operations,
and focus on a single media stream between two full
implementations.
</t>

<figure title="Example Flow" anchor="fig:basic-ex"><artwork>
<![CDATA[
          L             NAT           STUN             R
          |STUN alloc.   |              |              |
          |(1) STUN Req  |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$STUN-PUB-1 |              |              |
          |------------->|              |              |
          |              |(2) STUN Req  |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$STUN-PUB-1 |              |
          |              |------------->|              |
          |              |(3) STUN Res  |              |
          |              |S=$STUN-PUB-1 |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |<-------------|              |
          |(4) STUN Res  |              |              |
          |S=$STUN-PUB-1 |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |<-------------|              |              |
          |(5) L's Candidate Information|              |
          |------------------------------------------->|
          |              |              |              | STUN
          |              |              |              | alloc.
          |              |              |(6) STUN Req  |
          |              |              |S=$R-PUB-1    |
          |              |              |D=$STUN-PUB-1 |
          |              |              |<-------------|
          |              |              |(7) STUN Res  |
          |              |              |S=$STUN-PUB-1 |
          |              |              |D=$R-PUB-1    |
          |              |              |MA=$R-PUB-1   |
          |              |              |------------->|
          |(8) R's Candidate Information|              |
          |<-------------------------------------------|
          |              |(9) Bind Req  |              |Begin
          |              |S=$R-PUB-1    |              |Connectivity
          |              |D=L-PRIV-1    |              |Checks
          |              |<----------------------------|
          |              |Dropped       |              |
          |(10) Bind Req |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |------------->|              |              |
          |              |(11) Bind Req |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |---------------------------->|
          |              |(12) Bind Res |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |<----------------------------|
          |(13) Bind Res |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |<-------------|              |              |
          |Media flows   |              |              |
          |              |(14) Bind Req |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |<----------------------------|
          |(15) Bind Req |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |<-------------|              |              |
          |(16) Bind Res |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |MA=$R-PUB-1   |              |              |
          |------------->|              |              |
          |              |(17) Bind Res |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |MA=$R-PUB-1   |              |
          |              |---------------------------->|
          |              |              |              |Media flows

]]></artwork></figure>

<t> First, agent L obtains a host candidate from its local IP address
(not shown), and from that, sends a STUN Binding request to the STUN
server to get a server reflexive candidate (messages 1-4). Recall that
the NAT has the address and port independent mapping property. Here,
it creates a binding of NAT-PUB-1 for this UDP request, and this
becomes the server reflexive candidate.  </t>

<t>
Agent L sets a type preference of 126 for the host candidate and 100
for the server reflexive. The local preference is 65535. Based on
this, the priority of the host candidate is 2130706431 and for the
server reflexive candidate is 1694498815. The host candidate is
assigned a foundation of 1, and the server reflexive, a foundation of
2. These are sent to the peer.
</t>

<t>
This candidate information is received at agent R. Agent R will obtain
a host candidate, and from it, obtain a server reflexive candidate
(messages 6-7). Since R is not behind a NAT, this candidate is
identical to its host candidate, and they share the same base. It
therefore discards this redundant candidate and ends up with a single
host candidate. With identical type and local preferences as L, the
priority for this candidate is 2130706431. It chooses a foundation of
1 for its single candidate. Then R's candidates are then sent to
L. </t>

<t>
Since neither side indicated that it is lite, the initiating agent
that began ICE processing (agent L) becomes the controlling agent.
</t>

<t>Agents L and R both pair up the candidates. They both initially
have two pairs. However, agent L will prune the pair containing its
server reflexive candidate, resulting in just one. At agent L, this
pair has a local candidate of $L_PRIV_1 and remote candidate of
$R_PUB_1, and has a candidate pair priority of 4.57566E+18 (note that
an implementation would represent this as a 64-bit integer so as not
to lose precision). At agent R, there are two pairs. The highest
priority has a local candidate of $R_PUB_1 and remote candidate of
$L_PRIV_1 and has a priority of 4.57566E+18, and the second has a
local candidate of $R_PUB_1 and remote candidate of $NAT_PUB_1 and
priority 3.63891E+18.
</t>

<t> Agent R begins its connectivity check (message 9) for the first
pair (between the two host candidates). Since R is the controlled
agent for this session, the check omits the USE-CANDIDATE
attribute. The host candidate from agent L is private and behind a
NAT, and thus this check won't be successful, because the packet
cannot be routed from R to L.
</t>

<t> When agent L gets the R's candidates, it performs its one and only
connectivity check (messages 10-13). Since the check succeeds, agent L
creates a new pair, whose local candidate is from the mapped address
in the Binding response (NAT-PUB-1 from message 13) and whose remote
candidate is the destination of the request (R-PUB-1 from message
10). This is added to the valid list. Agent L can now send media if it
so chooses.
</t>

<t>
Soon after receipt of the STUN Binding request from agent L (message
11), agent R will generate its triggered check. This check happens to
match the next one on its check list -- from its host candidate to
agent L's server reflexive candidate. This check (messages 14-17) will
succeed. Consequently, agent R constructs a new candidate pair using
the mapped address from the response as the local candidate (R-PUB-1)
and the destination of the request (NAT-PUB-1) as the remote
candidate. This pair is added to the valid list for that media
stream. Agent R can also send media.
</t>

</section>

<section anchor="sec-security" title="Security Considerations">

<t>
There are several types of attacks possible in an ICE system. This
section considers these attacks and their countermeasures. These
countermeasures include:
<list style="symbols">
<t>Using ICE in conjunction with secure signaling techniques, such as
SIPS.</t>
<t>Limiting the total number of connectivity checks to 100, and
optionally limiting the number of candidates they'll accept in an
candidate exchange.</t>
</list>
</t>


<section title="Attacks on Connectivity Checks">

<t>
An attacker might attempt to disrupt the STUN connectivity
checks. Ultimately, all of these attacks fool an agent into thinking
something incorrect about the results of the connectivity checks. The
possible false conclusions an attacker can try and cause are:
</t>

<t><list style="hanging">

<t hangText="False Invalid:">An attacker can fool a pair of agents
into thinking a candidate pair is invalid, when it isn't. This can be
used to cause an agent to prefer a different candidate (such as one
injected by the attacker) or to disrupt a call by forcing all
candidates to fail.
</t>

<t hangText="False Valid:">An attacker can fool a pair of agents into
thinking a candidate pair is valid, when it isn't. This can cause an
agent to proceed with a session, but then not be able to receive any
media.
</t>

<t hangText="False Peer Reflexive Candidate:">An attacker can cause an
agent to discover a new peer reflexive candidate, when it shouldn't
have. This can be used to redirect media streams to a
Denial-of-Service (DoS) target or to the attacker, for eavesdropping
or other purposes.
</t>

<t hangText="False Valid on False Candidate:">An attacker has already
convinced an agent that there is a candidate with an address that
doesn't actually route to that agent (for example, by injecting a
false peer reflexive candidate or false server reflexive
candidate). It must then launch an attack that forces the agents to
believe that this candidate is valid.
</t>

<t>
If an attacker can cause a false peer reflexive candidate or false
valid on a false candidate, it can launch any of the attacks described
in <xref target="RFC5389"/>.
</t>

</list></t>

<t> To force the false invalid result, the attacker has to wait for
the connectivity check from one of the agents to be sent. When it is,
the attacker needs to inject a fake response with an unrecoverable
error response, such as a 400. However, since the candidate is, in
fact, valid, the original request may reach the peer agent, and result
in a success response. The attacker needs to force this packet or its
response to be dropped, through a DoS attack, layer 2 network
disruption, or other technique. If it doesn't do this, the success
response will also reach the originator, alerting it to a possible
attack. Fortunately, this attack is mitigated completely through the
STUN short-term credential mechanism. The attacker needs to inject a
fake response, and in order for this response to be processed, the
attacker needs the password. If the candidate exchange signaling is
secured, the attacker will not have the password and its response will
be discarded.
</t>

<t> Forcing the fake valid result works in a similar way. The agent
needs to wait for the Binding request from each agent, and inject a
fake success response. The attacker won't need to worry about
disrupting the actual response since, if the candidate is not valid,
it presumably wouldn't be received anyway. However, like the fake
invalid attack, this attack is mitigated by the STUN short-term
credential mechanism in conjunction with a secure candidate exchange.
</t>

<t>Forcing the false peer reflexive candidate result can be done
either with fake requests or responses, or with replays. We consider
the fake requests and responses case first. It requires the attacker
to send a Binding request to one agent with a source IP address and
port for the false candidate. In addition, the attacker must wait for
a Binding request from the other agent, and generate a fake response
with a XOR-MAPPED-ADDRESS attribute containing the false
candidate. Like the other attacks described here, this attack is
mitigated by the STUN message integrity mechanisms and secure
candidate exchanges.
</t>

<t>Forcing the false peer reflexive candidate result with packet
replays is different. The attacker waits until one of the agents sends
a check. It intercepts this request, and replays it towards the other
agent with a faked source IP address. It must also prevent the
original request from reaching the remote agent, either by launching a
DoS attack to cause the packet to be dropped, or forcing it to be
dropped using layer 2 mechanisms. The replayed packet is received at
the other agent, and accepted, since the integrity check passes (the
integrity check cannot and does not cover the source IP address and
port). It is then responded to. This response will contain a
XOR-MAPPED-ADDRESS with the false candidate, and will be sent to that
false candidate.  The attacker must then receive it and relay it
towards the originator.
</t>

<t>The other agent will then initiate a connectivity check towards
that false candidate. This validation needs to succeed. This requires
the attacker to force a false valid on a false candidate. Injecting of
fake requests or responses to achieve this goal is prevented using the
integrity mechanisms of STUN and the candidate exchange. Thus, this
attack can only be launched through replays. To do that, the attacker
must intercept the check towards this false candidate, and replay it
towards the other agent. Then, it must intercept the response and
replay that back as well.  </t>

<t>
This attack is very hard to launch unless the attacker is identified
by the fake candidate. This is because it requires the attacker to
intercept and replay packets sent by two different hosts. If both
agents are on different networks (for example, across the public
Internet), this attack can be hard to coordinate, since it needs to
occur against two different endpoints on different parts of the
network at the same time.
</t>

<t>
If the attacker itself is identified by the fake candidate, the attack
is easier to coordinate. However, if the media path is secured (e.g.,
using SRTP <xref target="RFC3711"/>), the attacker will not be able to
play the media packets, but will only be able to discard them,
effectively disabling the media stream for the call. However, this
attack requires the agent to disrupt packets in order to block the
connectivity check from reaching the target. In that case, if the goal
is to disrupt the media stream, it's much easier to just disrupt it
with the same mechanism, rather than attack ICE.
</t>

</section>

<section title="Attacks on Server Reflexive Address Gathering">

<t>
ICE endpoints make use of STUN Binding requests for gathering server
reflexive candidates from a STUN server. These requests are not
authenticated in any way. As a consequence, there are numerous
techniques an attacker can employ to provide the client with a false
server reflexive candidate:

<list style="symbols">
<t>An attacker can compromise the DNS, causing DNS queries to return a
  rogue STUN server address. That server can provide the client with
  fake server reflexive candidates. This attack is mitigated by DNS
  security, though DNS-SEC is not required to address it.
</t>

<t>
  An attacker that can observe STUN messages (such as an attacker on a
  shared network segment, like WiFi) can inject a fake response that
  is valid and will be accepted by the client.
</t>

<t>
  An attacker can compromise a STUN server by means of a virus, and
  cause it to send responses with incorrect mapped addresses.
</t>
</list>

</t>

<t>
A false mapped address learned by these attacks will be used as a
server reflexive candidate in the ICE exchange. For this candidate to
actually be used for media, the attacker must also attack the
connectivity checks, and in particular, force a false valid on a false
candidate. This attack is very hard to launch if the false address
identifies a fourth party (neither the initiator, responder, nor
attacker), since it requires attacking the checks generated by each
agent in the session, and is prevented by SRTP if it identifies the
attacker themself.
</t>

<t>If the attacker elects not to attack the connectivity checks, the
worst it can do is prevent the server reflexive candidate from being
used. However, if the peer agent has at least one candidate that is
reachable by the agent under attack, the STUN connectivity checks
themselves will provide a peer reflexive candidate that can be used
for the exchange of media. Peer reflexive candidates are generally
preferred over server reflexive candidates. As such, an attack solely
on the STUN address gathering will normally have no impact on a session
at all.  </t>

</section>

<section title="Attacks on Relayed Candidate Gathering">

<t>
An attacker might attempt to disrupt the gathering of relayed
candidates, forcing the client to believe it has a false relayed
candidate. Exchanges with the TURN server are authenticated using a
long-term credential. Consequently, injection of fake responses or
requests will not work. In addition, unlike Binding requests, Allocate
requests are not susceptible to replay attacks with modified source IP
addresses and ports, since the source IP address and port are not
utilized to provide the client with its relayed candidate.
</t>

<t>
However, TURN servers are susceptible to DNS attacks, or to viruses
aimed at the TURN server, for purposes of turning it into a zombie or
rogue server. These attacks can be mitigated by DNS-SEC and through
good box and software security on TURN servers.
</t>

<t>
Even if an attacker has caused the client to believe in a false
relayed candidate, the connectivity checks cause such a candidate to
be used only if they succeed. Thus, an attacker must launch a false
valid on a false candidate, per above, which is a very difficult
attack to coordinate.
</t>

</section>

<section title="Insider Attacks">

<t>
In addition to attacks where the attacker is a third party trying to
insert fake candidate information or stun messages, there are attacks
possible with ICE when the attacker is an authenticated and valid
participant in the ICE exchange.
</t>

<section anchor="sec-ice-hammer" title="STUN Amplification Attack">

<t>
The STUN amplification attack is similar to the voice hammer. However,
instead of voice packets being directed to the target, STUN
connectivity checks are directed to the target. The attacker sends an
a large number of candidates, say, 50. The responding agent receives
the candidate information, and starts its checks, which are directed
at the target, and consequently, never generate a response. The
answerer will start a new connectivity check every Ta ms (say,
Ta=20ms). However, the retransmission timers are set to a large number
due to the large number of candidates. As a consequence, packets will
be sent at an interval of one every Ta milliseconds, and then with
increasing intervals after that. Thus, STUN will not send packets at a
rate faster than media would be sent, and the STUN packets persist
only briefly, until ICE fails for the session. Nonetheless, this is an
amplification mechanism.
</t>

<t>
It is impossible to eliminate the amplification, but the volume can be
reduced through a variety of heuristics. Agents SHOULD limit the total
number of connectivity checks they perform to 100. Additionally,
agents MAY limit the number of candidates they'll accept.
</t>

<t>
Frequently, protocols that wish to avoid these kinds of attacks force
the initiator to wait for a response prior to sending the next
message. However, in the case of ICE, this is not possible. It is not
possible to differentiate the following two cases:
<list style="symbols">
<t>There was no response because the initiator is being used to launch
  a DoS attack against an unsuspecting target that will not respond.
</t>
<t>There was no response because the IP address and port are not
  reachable by the initiator.
</t>
</list>
In the second case, another check should be sent at the next
opportunity, while in the former case, no further checks should be
sent.
</t>


</section>

</section>



</section>

<section title="STUN Extensions">

<section anchor="sec-ice-newatts" title="New Attributes">

<t>
This specification defines four new STUN attributes, PRIORITY,
USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.
</t>

<t>
The PRIORITY attribute indicates the priority that is to be
associated with a peer reflexive candidate, should one be discovered
by this check. It is a 32-bit unsigned integer, and has an attribute
value of 0x0024.
</t>

<t>
The USE-CANDIDATE attribute indicates that the candidate pair
resulting from this check should be used for transmission of
media. The attribute has no content (the Length field of the attribute
is zero); it serves as a flag. It has an attribute value of 0x0025.
</t>

<t>
The ICE-CONTROLLED attribute is present in a Binding request and
indicates that the client believes it is currently in the controlled
role. The content of the attribute is a 64-bit unsigned integer in
network byte order, which contains a random number. The number is used
for solving role conflicts, when it is referred to as the tie-breaker
value. An ICE agent MUST use the same number for all Binding requests,
for all streams, within an ICE session. The ICE agent MUST NOT change
the number when an ICE restart occurs.
</t>

<t>
The ICE-CONTROLLING attribute is present in a Binding request and
indicates that the client believes it is currently in the controlling
role. The content of the attribute is a 64-bit unsigned integer in
network byte order, which contains a random number. The number is used
for solving role conflicts, when it is referred to as the tie-breaker
value. An ICE agent MUST use the same number for all Binding requests,
for all streams, within an ICE session. The ICE agent MUST NOT change
the number when an ICE restart occurs.
</t>

</section>

<section title="New Error Response Codes">

<t>This specification defines a single error response code:</t>

<t><list style="hanging">

<t hangText="487 (Role Conflict):"> The Binding request contained
either the ICE-CONTROLLING or ICE-CONTROLLED attribute, indicating an
ICE role that conflicted with the server. The server compared the
tie-breaker values of the client and the server and determined that
the client needs to switch roles.  </t>

</list></t>

</section>

</section>

<section title="Operational Considerations">

<t>
This section discusses issues relevant to network operators looking to
deploy ICE.
</t>

<section title="NAT and Firewall Types">

<t>
ICE was designed to work with existing NAT and firewall
equipment. Consequently, it is not necessary to replace or reconfigure
existing firewall and NAT equipment in order to facilitate deployment
of ICE. Indeed, ICE was developed to be deployed in environments where
the Voice over IP (VoIP) operator has no control over the IP network
infrastructure, including firewalls and NAT.
</t>

<t>
That said, ICE works best in environments where the NAT devices are
"behave" compliant, meeting the recommendations defined in <xref
target="RFC4787"/> and <xref target="RFC5382"/>. In networks with
behave-compliant NAT, ICE will work without the need for a TURN
server, thus improving voice quality, decreasing call setup times, and
reducing the bandwidth demands on the network operator.
</t>

</section>

<section title="Bandwidth Requirements">

<t>
Deployment of ICE can have several interactions with available network
capacity that operators should take into consideration.
</t>

<section title="STUN and TURN Server Capacity Planning">

<t>
First and foremost, ICE makes use of TURN and STUN servers, which
would typically be located in the network operator's data centers. The
STUN servers require relatively little bandwidth. For each component
of each media stream, there will be one or more STUN transactions from
each client to the STUN server. In a basic voice-only IPv4 VoIP
deployment, there will be four transactions per call (one for RTP and
one for RTCP, for both caller and callee). Each transaction
is a single request and a single response, the former being 20 bytes
long, and the latter, 28. Consequently, if a system has N users, and
each makes four calls in a busy hour, this would require N*1.7bps. For
one million users, this is 1.7 Mbps, a very small number (relatively
speaking).
</t>

<t>
TURN traffic is more substantial. The TURN server will see traffic
volume equal to the STUN volume (indeed, if TURN servers are deployed,
there is no need for a separate STUN server), in addition to the
traffic for the actual media. The amount of calls requiring
TURN for media relay is highly dependent on network topologies, and
can and will vary over time. In a network with 100% behave-compliant
NAT, it is exactly zero. At time of writing, large-scale consumer
deployments were seeing between 5 and 10 percent of calls requiring
TURN servers. Considering a voice-only deployment using G.711 (so 80
kbps in each direction), with .2 erlangs during the busy hour, this is
N*3.2 kbps. For a population of one million users, this is 3.2 Gbps,
assuming a 10% usage of TURN servers.
</t>

</section>

<section title="Gathering and Connectivity Checks">

<t>
The process of gathering of candidates and performing of connectivity
checks can be bandwidth intensive. ICE has been designed to pace both
of these processes. The gathering phase and the connectivity check
phase are meant to generate traffic at roughly the same bandwidth as
the media traffic itself. This was done to ensure that, if a network
is designed to support multimedia traffic of a certain type (voice,
video, or just text), it will have sufficient capacity to support the
ICE checks for that media. Of course, the ICE checks will cause a
marginal increase in the total utilization; however, this will
typically be an extremely small increase.
</t>

<t>
Congestion due to the gathering and check phases has proven to be a
problem in deployments that did not utilize pacing. Typically, access
links became congested as the endpoints flooded the network with
checks as fast as they can send them. Consequently, network operators
should make sure that their ICE implementations support the pacing
feature. Though this pacing does increase call setup times, it makes
ICE network friendly and easier to deploy.
</t>

</section>

<section title="Keepalives">

<t>
Keepalives are sent in
the middle of a media session. However, they are sent only in the
absence of actual media traffic. 
In scenarios where media is being sent continuously,
keepalives are never used and
there is no increase in bandwidth usage. When media is not being sent continuously,
keepalives will be sent during periods when no media is being sent. 
This involves a single
packet every 15-20 seconds, which compared to most media flows is minor. 
Therefore, keepalives don't have any
real impact on capacity planning.
</t>

</section>

</section>

<section title="ICE and ICE-lite">

<t>
Deployments utilizing a mix of ICE and ICE-lite interoperate
perfectly. They have been explicitly designed to do so, without loss
of function.
</t>

<t>
However, ICE-lite can only be deployed in limited use cases. Those
cases, and the caveats involved in doing so, are documented in
<xref target="sec-liteandfull"/>.
</t>

</section>

<section title="Troubleshooting and Performance Management">

<t>
ICE utilizes end-to-end connectivity checks, and places much of the
processing in the endpoints. This introduces a challenge to the
network operator -- how can they troubleshoot ICE deployments? How can
they know how ICE is performing?
</t>

<t>
ICE has built-in features to help deal with these problems. Signaling
servers, typically deployed in the data centers
of the network operator, will see the contents of the candidate
exchanges that convey the ICE parameters. These parameters include the
type of each candidate (host, server reflexive, or relayed), along
with their related addresses. Once ICE processing has completed, an
updated candidate exchange takes place, signaling the selected
address (and its type). This updated signaling is performed exactly
for the purposes of educating network equipment (such as a diagnostic
tool attached to a signaling) about the results of ICE processing.
</t>

<t>
As a consequence, through the logs generated by a signaling server, a
network operator can observe what types of candidates are being used
for each call, and what address were selected by ICE. This is the
primary information that helps evaluate how ICE is performing.
</t>

</section>

<section title="Endpoint Configuration">

<t>
ICE relies on several pieces of data being configured into the
endpoints. This configuration data includes timers, credentials for
TURN servers, and hostnames for STUN and TURN servers. ICE itself does
not provide a mechanism for this configuration. Instead, it is assumed
that this information is attached to whatever mechanism is used to
configure all of the other parameters in the endpoint. For SIP phones,
standard solutions such as the configuration framework
<xref target="RFC6080"/> have been defined.
</t>

</section>

</section>

<section title="IANA Considerations">

<t>
The original ICE specification registered four new STUN attributes,
and one new STUN error response. The STUN attributes and error
response are reproduced here. In addition, this specification
registers a new ICE option.
</t>


<section title="STUN Attributes">

<t>
IANA has registered four STUN attributes:
</t>

<figure><artwork>
<![CDATA[
   0x0024 PRIORITY
   0x0025 USE-CANDIDATE
   0x8029 ICE-CONTROLLED
   0x802A ICE-CONTROLLING
]]></artwork></figure>

</section>

<section title="STUN Error Responses">

<t>
IANA has registered following STUN error response code:
</t>

<figure><artwork>
<![CDATA[
 487   Role Conflict: The client asserted an ICE role (controlling or
       controlled) that is in conflict with the role of the server.
]]></artwork></figure>


</section>

<section title="ICE Options">

<t>
IANA is requested to register the following ICE option in the "ICE Options"
sub-registry of the "Interactive Connectivity Establishment (ICE) registry",
following the procedures defined in <xref target="RFC6336"/>.
</t>

<figure><artwork>
<![CDATA[

ICE Option name:

     ice2

  Contact:

     Name:    Christer Holmberg
     E-mail:  christer.holmberg(at)ericsson(dot)com
     Address: Oy LM Ericsson Ab, 02420 Jorvas, FINLAND

  Change control:

     IESG

  Description:

     The ICE option indicates that the ICE agent using the ICE option
     is compliant and implemented according to RFC XXXX.

  Reference:

     RFC XXXX

]]></artwork></figure>


</section>

</section>


<section anchor="sec-iab" title="IAB Considerations">

<t>
The IAB has studied the problem of "Unilateral Self-Address Fixing",
which is the general process by which a agent attempts to determine
its address in another realm on the other side of a NAT through a
collaborative protocol reflection mechanism <xref target="RFC3424"/>.
ICE is an example of a protocol that performs this type of
function. Interestingly, the process for ICE is not unilateral, but
bilateral, and the difference has a significant impact on the issues
raised by IAB. Indeed, ICE can be considered a B-SAF (Bilateral
Self-Address Fixing) protocol, rather than an UNSAF
protocol. Regardless, the IAB has mandated that any protocols
developed for this purpose document a specific set of
considerations. This section meets those requirements.
</t>

<section title="Problem Definition">

<t>
From RFC 3424, any UNSAF proposal must provide:
</t>

<t><list style="hanging">
<t>
Precise definition of a specific, limited-scope problem that is to be
solved with the UNSAF proposal.  A short-term fix should not be
generalized to solve other problems; this is why "short-term fixes
usually aren't".
</t>
</list></t>

<t>
The specific problems being solved by ICE are:
</t>

<t><list style="hanging">

<t>
Provide a means for two peers to determine the set of transport
addresses that can be used for communication.
</t>

<t>
Provide a means for a agent to determine an address that is
reachable by another peer with which it wishes to communicate.
</t>

</list></t>

</section>

<section title="Exit Strategy">

<t>
From RFC 3424, any UNSAF proposal must provide:
</t>

<t><list style="hanging"><t>
Description of an exit strategy/transition plan.  The better
short-term fixes are the ones that will naturally see less and
less use as the appropriate technology is deployed.
</t></list></t>

<t> ICE itself doesn't easily get phased out. However, it is useful
even in a globally connected Internet, to serve as a means for
detecting whether a router failure has temporarily disrupted
connectivity, for example. ICE also helps prevent certain security
attacks that have nothing to do with NAT. However, what ICE does is
help phase out other UNSAF mechanisms. ICE effectively selects amongst
those mechanisms, prioritizing ones that are better, and
deprioritizing ones that are worse. Local IPv6 addresses can be
preferred. As NATs begin to dissipate as IPv6 is introduced, server
reflexive and relayed candidates (both forms of UNSAF addresses)
simply never get used, because higher-priority connectivity exists to
the native host candidates. Therefore, the servers get used less and
less, and can eventually be remove when their usage goes to zero.
</t>

<t>
Indeed, ICE can assist in the transition from IPv4 to IPv6. It can be
used to determine whether to use IPv6 or IPv4 when two dual-stack
hosts communicate with SIP (IPv6 gets used). It can also allow a
network with both 6to4 and native v6 connectivity to determine which
address to use when communicating with a peer.
</t>

</section>

<section title="Brittleness Introduced by ICE">

<t>
From RFC 3424, any UNSAF proposal must provide:
</t>

<t><list style="hanging"><t>
Discussion of specific issues that may render systems more
"brittle".  For example, approaches that involve using data at
multiple network layers create more dependencies, increase
debugging challenges, and make it harder to transition.
</t></list></t>

<t> ICE actually removes brittleness from existing UNSAF
mechanisms. In particular, classic STUN (as described in RFC 3489
<xref target="RFC3489"/>) has several points of brittleness. One of
them is the discovery process that requires an agent to try to
classify the type of NAT it is behind. This process is
error-prone. With ICE, that discovery process is simply not
used. Rather than unilaterally assessing the validity of the address,
its validity is dynamically determined by measuring connectivity to a
peer. The process of determining connectivity is very robust.  </t>

<t>
Another point of brittleness in classic STUN and any other unilateral
mechanism is its absolute reliance on an additional server. ICE makes
use of a server for allocating unilateral addresses, but allows
agents to directly connect if possible. Therefore, in some cases, the
failure of a STUN server would still allow for a call to
progress when ICE is used.
</t>

<t>
Another point of brittleness in classic STUN is that it assumes
that the STUN server is on the public Internet. Interestingly, with
ICE, that is not necessary. There can be a multitude of STUN servers
in a variety of address realms. ICE will discover the one that has
provided a usable address.
</t>

<t>
The most troubling point of brittleness in classic STUN is that it
doesn't work in all network topologies. In cases where there is a
shared NAT between each agent and the STUN server, traditional STUN
may not work. With ICE, that restriction is removed.
</t>

<t>
Classic STUN also introduces some security
considerations. Fortunately, those security considerations are also
mitigated by ICE.
</t>

<t>
Consequently, ICE serves to repair the brittleness introduced in
classic STUN, and does not introduce any additional brittleness
into the system.
</t>

<t>
The penalty of these improvements is that ICE increases session
establishment times.
</t>

</section>

<section title="Requirements for a Long-Term Solution">

<t>From RFC 3424, any UNSAF proposal must provide:
</t>

<t><list style="hanging"><t>
... requirements for longer term, sound technical solutions
-- contribute to the process of finding the right longer term
solution.
</t>
</list></t>

<t>
Our conclusions from RFC 3489 remain unchanged. However, we feel ICE
actually helps because we believe it can be part of the long-term
solution.
</t>

</section>

<section title="Issues with Existing NAPT Boxes">

<t>From RFC 3424, any UNSAF proposal must provide:
</t>

<t><list style="hanging"><t>
Discussion of the impact of the noted practical issues with
existing, deployed NA[P]Ts and experience reports.
</t></list></t>

<t>
A number of NAT boxes are now being deployed into the market that try
to provide "generic" ALG functionality. These generic ALGs hunt for IP
addresses, either in text or binary form within a packet, and rewrite
them if they match a binding. This interferes with classic
STUN. However, the update to STUN <xref target="RFC5389"/> uses an
encoding that hides these binary addresses from generic ALGs.
</t>

<t>
Existing NAPT boxes have non-deterministic and typically short
expiration times for UDP-based bindings. This requires implementations
to send periodic keepalives to maintain those bindings. ICE uses a
default of 15 s, which is a very conservative estimate. Eventually,
over time, as NAT boxes become compliant to behave <xref
target="RFC4787"/>, this minimum keepalive will become deterministic
and well-known, and the ICE timers can be adjusted. Having a way to
discover and control the minimum keepalive interval would be far
better still.
</t>

</section>

</section>

<section title="Changes from RFC 5245">

<t> Following is the list of changes from RFC 5245
<list style="symbols">
<t> The specification was generalized to be more usable with any
protocol and the parts that are specific to SIP and SDP were moved to
a SIP/SDP usage document <xref
target="I-D.ietf-mmusic-ice-sip-sdp"/>. </t>
<t> Default candidates, multiple components, ICE mismatch detection,
subsequent offer/answer, and role conflict resolution were made
optional since they are not needed with every protocol using ICE. </t>
<t>
With IPv6, the precedence rules of RFC 6724 are used instead of the
obsoleted RFC 3483 and using address preferences provided by the host
operating system is recommended. </t>
<t> Candidate gathering rules regarding loopback addresses and IPv6
addresses were clarified. </t>

</list>

</t>

</section>

<section title="Acknowledgements">

<t> Most of the text in this document comes from the original ICE
specification, RFC 5245. The authors would like to thank everyone who
has contributed to that document. For additional contributions to this
revision of the specification we would like to thank Emil Ivov, Paul
Kyzivat, Pal-Erik Martinsen, Simon Perrault, Eric Rescorla, Thomas
Stach, Peter Thatcher, Martin Thomson, Justin Uberti, and Suhas
Nandakumar. </t>

</section>

</middle>

<back>
<references title="Normative References">
<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.5389"?>
<?rfc include="reference.RFC.5766"?>
<?rfc include="reference.RFC.6336"?>
<?rfc include="reference.RFC.6724"?>
</references>

<references title="Informative References">
<?rfc include="reference.RFC.3605"?>
<?rfc include="reference.RFC.3261"?>
<?rfc include="reference.RFC.3264"?>
<?rfc include="reference.RFC.3489"?>
<?rfc include="reference.RFC.3235"?>
<?rfc include="reference.RFC.3303"?>
<?rfc include="reference.RFC.3102"?>
<?rfc include="reference.RFC.3103"?>
<?rfc include="reference.RFC.3424"?>
<?rfc include="reference.RFC.3550"?>
<?rfc include="reference.RFC.3711"?>
<?rfc include="reference.RFC.3879"?>
<?rfc include="reference.RFC.4038"?>
<?rfc include="reference.RFC.4091"?>
<?rfc include="reference.RFC.4092"?>
<?rfc include="reference.RFC.4291"?>
<?rfc include="reference.RFC.4566"?>
<?rfc include="reference.RFC.2475"?>
<?rfc include="reference.RFC.1918"?>
<?rfc include="reference.RFC.4787"?>
<?rfc include="reference.RFC.5761"?>
<?rfc include="reference.RFC.4103"?>
<?rfc include="reference.RFC.5245"?>
<?rfc include="reference.RFC.5382"?>
<?rfc include="reference.RFC.6080"?>
<?rfc include="reference.RFC.6146"?>
<?rfc include="reference.RFC.6147"?>
<?rfc include="reference.RFC.6544"?>
<?rfc include="reference.RFC.7050"?>
<?rfc include="reference.I-D.ietf-mmusic-ice-sip-sdp"?>
<?rfc include="reference.RFC.7721"?>
<?rfc include="reference.I-D.ietf-ice-dualstack-fairness"?>

</references>

<section anchor="sec-liteandfull" title="Lite and Full Implementations">

<t>
ICE allows for two types of implementations. A full implementation
supports the controlling and controlled roles in a session, and can
also perform address gathering. In contrast, a lite implementation is
a minimalist implementation that does little but respond to STUN
checks.
</t>

<t>
Because ICE requires both endpoints to support it in order to bring
benefits to either endpoint, incremental deployment of ICE in a
network is more complicated. Many sessions involve an endpoint that
is, by itself, not behind a NAT and not one that would worry about NAT
traversal. A very common case is to have one endpoint that requires
NAT traversal (such as a VoIP hard phone or soft phone) make a call to
one of these devices. Even if the phone supports a full ICE
implementation, ICE won't be used at all if the other device doesn't
support it. The lite implementation allows for a low-cost entry point
for these devices. Once they support the lite implementation, full
implementations can connect to them and get the full benefits of ICE.
</t>

<t>
Consequently, a lite implementation is only appropriate for devices
that will *always* be connected to the public Internet and have a
public IP address at which it can receive packets from any
correspondent. ICE will not function when a lite implementation is
placed behind a NAT.
</t>

<t>
ICE allows a lite implementation to have a single IPv4 host candidate
and several IPv6 addresses. In that case, candidate pairs are selected
by the controlling agent using a static algorithm, such as the one in
RFC 6724, which is recommended by this specification. However, static
mechanisms for address selection are always prone to error, since they
cannot ever reflect the actual topology and can never provide actual
guarantees on connectivity. They are always heuristics. Consequently,
if an agent is implementing ICE just to select between its IPv4 and
IPv6 addresses, and none of its IP addresses are behind NAT, usage
of full ICE is still RECOMMENDED in order to provide the most robust
form of address selection possible.
</t>

<t>
It is important to note that the lite implementation was added to this
specification to provide a stepping stone to full implementation. Even
for devices that are always connected to the public Internet with just
a single IPv4 address, a full implementation is preferable if
achievable. Full implementations also obtain
the security benefits of ICE unrelated to NAT traversal; in
particular, the voice hammer attack described in <xref
target="sec-security"/> is prevented only for full implementations,
not lite. Finally, it is often the case that a device that finds
itself with a public address today will be placed in a network
tomorrow where it will be behind a NAT. It is difficult to
definitively know, over the lifetime of a device or product, that it
will always be used on the public Internet. Full implementation
provides assurance that communications will always work.
</t>

</section>

<section title="Design Motivations">

<t>
ICE contains a number of normative behaviors that may themselves be
simple, but derive from complicated or non-obvious thinking or use
cases that merit further discussion. Since these design motivations
are not necessary to understand for purposes of implementation, they
are discussed here in an appendix to the specification. This section
is non-normative.
</t>


<section anchor="sec-pacing" title="Pacing of STUN Transactions">

<t>
STUN transactions used to gather candidates and to verify connectivity
are paced out at an approximate rate of one new transaction every Ta
milliseconds. Each transaction, in turn, has a retransmission timer
RTO that is a function of Ta as well. Why are these transactions
paced, and why are these formulas used?
</t>

<t> Sending of these STUN requests will often have the effect of
creating bindings on NAT devices between the client and the STUN
servers. Experience has shown that many NAT devices have upper limits
on the rate at which they will create new bindings. Experiments have
shown that once every 5 ms is well supported.
This is why Ta has a lower bound of 5 ms. Furthermore,
transmission of these packets on the network makes use of bandwidth
and needs to be rate limited by the agent. Deployments based on
earlier draft versions of <xref target="RFC5245"/> tended to overload
rate-constrained access links and perform poorly overall, in addition
to negatively impacting the network. As a consequence, the pacing
ensures that the NAT device does not get overloaded and that traffic
is kept at a reasonable rate.
</t>

<t>
The definition of a "reasonable" rate is that STUN should not use more
bandwidth than the RTP itself will use, once media starts flowing. The
formula for Ta is designed so that, if a STUN packet were sent every
Ta seconds, it would consume the same amount of bandwidth as RTP
packets, summed across all media streams. Of course, STUN has
retransmits, and the desire is to pace those as well. For this reason,
RTO is set such that the first retransmit on the first transaction
happens just as the first STUN request on the last transaction
occurs. Pictorially:
</t>

<figure><artwork>
<![CDATA[

           First Packets              Retransmits



                 |                        |
                 |                        |
          -------+------           -------+------
         /               \        /               \
        /                 \      /                 \

        +--+    +--+    +--+    +--+    +--+    +--+
        |A1|    |B1|    |C1|    |A2|    |B2|    |C2|
        +--+    +--+    +--+    +--+    +--+    +--+

     ---+-------+-------+-------+-------+-------+------------ Time
        0       Ta      2Ta     3Ta     4Ta     5Ta
]]></artwork></figure>

<t>
In this picture, there are three transactions that will be sent (for
example, in the case of candidate gathering, there are three host
candidate/STUN server pairs). These are transactions A, B, and C. The
retransmit timer is set so that the first retransmission on the first
transaction (packet A2) is sent at time 3Ta.
</t>

<t>
Subsequent retransmits after the first will occur even less frequently
than Ta milliseconds apart, since STUN uses an exponential back-off on
its retransmissions.
</t>

</section>

<section title="Candidates with Multiple Bases">

<t><xref target="sec-el-red"/> talks about eliminating candidates that
have the same transport address and base. However, candidates with the
same transport addresses but different bases are not redundant. When
can an agent have two candidates that have the same IP address and
port, but different bases? Consider the topology of <xref
target="fig-horror-net"/>:
</t>


<figure title="Identical Candidates with Different Bases"
anchor="fig-horror-net"><artwork>
<![CDATA[

       +----------+
       | STUN Srvr|
       +----------+
            |
            |
          -----
        //     \\
       |         |
      |  B:net10  |
       |         |
        \\     //
          -----
            |
            |
       +----------+
       |   NAT    |
       +----------+
            |
            |
          -----
        //     \\
       |    A    |
      |192.168/16 |
       |         |
        \\     //
          -----
            |
            |
            |192.168.1.100      -----
       +----------+           //     \\             +----------+
       |          |          |         |            |          |
       | Initiator|---------|  C:net10  |-----------| Responder|
       |          |10.0.1.100|         | 10.0.1.101 |          |
       +----------+           \\     //             +----------+
                                -----


]]></artwork></figure>

<t>
In this case, the initiating agent is multihomed. It has one IP
address, 10.0.1.100, on network C, which is a net 10 private
network. The responding agent is on this same network. The initiating
agent is also connected to network A, which is 192.168/16 and has an
IP address of 192.168.1.100 on this network. There is a NAT on this
network, natting into network B, which is another net 10 private
network, but not connected to network C. There is a STUN server on
network B.
</t>

<t>
The initiating agent obtains a host candidate on its IP address on
network C (10.0.1.100:2498) and a host candidate on its IP address on
network A (192.168.1.100:3344). It performs a STUN query to its
configured STUN server from 192.168.1.100:3344. This query passes
through the NAT, which happens to assign the binding
10.0.1.100:2498. The STUN server reflects this in the STUN Binding
response. Now, the initiating agent has obtained a server reflexive
candidate with a transport address that is identical to a host
candidate (10.0.1.100:2498). However, the server reflexive candidate
has a base of 192.168.1.100:3344, and the host candidate has a base of
10.0.1.100:2498.
</t>


</section>

<section anchor="sec-translation" title="Purpose of the Related Address and Related Port Attributes">
<t>
The candidate attribute contains two values that are not used at all
by ICE itself -- related address and related port. Why are they
present?
</t>

<t>
There are two motivations for its inclusion. The first is
diagnostic. It is very useful to know the relationship between the
different types of candidates. By including it, an agent can know
which relayed candidate is associated with which reflexive candidate,
which in turn is associated with a specific host candidate. When
checks for one candidate succeed and not for others, this provides
useful diagnostics on what is going on in the network.
</t>

<t>
The second reason has to do with off-path Quality of Service (QoS)
mechanisms. When ICE is used in environments such as PacketCable 2.0,
proxies will, in addition to performing normal SIP operations, inspect
the SDP in SIP messages, and extract the IP address and port for media
traffic. They can then interact, through policy servers, with access
routers in the network, to establish guaranteed QoS for the media
flows. This QoS is provided by classifying the RTP traffic based on
5-tuple, and then providing it a guaranteed rate, or marking its
Diffserv codepoints appropriately. When a residential NAT is present,
and a relayed candidate gets selected for media, this relayed
candidate will be a transport address on an actual TURN server. That
address says nothing about the actual transport address in the access
router that would be used to classify packets for QoS
treatment. Rather, the server reflexive candidate towards the TURN
server is needed. By carrying the translation in the SDP, the proxy
can use that transport address to request QoS from the access router.
</t>

</section>

<section anchor="sec-why-uname" title="Importance of the STUN Username">

<t>
ICE requires the usage of message integrity with STUN using its
short-term credential functionality. The actual short-term credential
is formed by exchanging username fragments in the candidate
exchange. The need for this mechanism goes beyond just security; it is
actually required for correct operation of ICE in the first place.
</t>

<t> Consider agents L, R, and Z. L and R are within private enterprise
1, which is using 10.0.0.0/8. Z is within private enterprise 2, which
is also using 10.0.0.0/8. As it turns out, R and Z both have IP
address 10.0.1.1. L sends candidates to Z. Z, in responds L with its
host candidates. In this case, those candidates are 10.0.1.1:8866 and
10.0.1.1:8877. As it turns out, R is in a session at that same time,
and is also using 10.0.1.1:8866 and 10.0.1.1:8877 as host
candidates. This means that R is prepared to accept STUN messages on
those ports, just as Z is. L will send a STUN request to 10.0.1.1:8866
and another to 10.0.1.1:8877. However, these do not go to Z as
expected. Instead, they go to R! If R just replied to them, L would
believe it has connectivity to Z, when in fact it has connectivity to
a completely different user, R. To fix this, the STUN short-term
credential mechanisms are used. The username fragments are
sufficiently random that it is highly unlikely that R would be using
the same values as Z. Consequently, R would reject the STUN request
since the credentials were invalid. In essence, the STUN username
fragments provide a form of transient host identifiers, bound to a
particular session established as part of the candidate exchange.
</t>

<t>
An unfortunate consequence of the non-uniqueness of IP addresses is
that, in the above example, R might not even be an ICE agent. It could
be any host, and the port to which the STUN packet is directed could
be any ephemeral port on that host. If there is an application
listening on this socket for packets, and it is not prepared to handle
malformed packets for whatever protocol is in use, the operation of
that application could be affected. Fortunately, since the ports
exchanged are ephemeral and usually drawn from the dynamic or
registered range, the odds are good that the port is not used to run a
server on host R, but rather is the agent side of some protocol. This
decreases the probability of hitting an allocated port, due to the
transient nature of port usage in this range. However, the possibility
of a problem does exist, and network deployers should be prepared for
it. Note that this is not a problem specific to ICE; stray packets can
arrive at a port at any time for any type of protocol, especially ones
on the public Internet. As such, this requirement is just restating a
general design guideline for Internet applications -- be prepared for
unknown packets on any port.
</t>

</section>

<section title="The Candidate Pair Priority Formula">

<t>
The priority for a candidate pair has an odd form. It is:
</t>

<t><list style="empty">
<t>pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)
</t>
</list></t>

<t>
Why is this? When the candidate pairs are sorted based on this value,
the resulting sorting has the MAX/MIN property. This means that the
pairs are first sorted based on decreasing value of the minimum of the
two priorities. For pairs that have the same value of the minimum
priority, the maximum priority is used to sort amongst them. If the
max and the min priorities are the same, the controlling agent's
priority is used as the tie-breaker in the last part of the
expression. The factor of 2*32 is used since the priority of a single
candidate is always less than 2*32, resulting in the pair priority
being a "concatenation" of the two component priorities.  This creates
the MAX/MIN sorting. MAX/MIN ensures that, for a particular agent, a
lower-priority candidate is never used until all higher-priority
candidates have been tried.
</t>

</section>



<section title="Why Are Keepalives Needed?">

<t>
Once media begins flowing on a candidate pair, it is still necessary
to keep the bindings alive at intermediate NATs for the duration of
the session. Normally, the media stream packets themselves (e.g., RTP)
meet this objective. However, several cases merit further
discussion. Firstly, in some RTP usages, such as SIP, the media
streams can be "put on hold". This is accomplished by using the SDP
"sendonly" or "inactive" attributes, as defined in RFC 3264 <xref
target="RFC3264"/>. RFC 3264 directs implementations to cease
transmission of media in these cases. However, doing so may cause NAT
bindings to timeout, and media won't be able to come off hold.
</t>

<t>
Secondly, some RTP payload formats, such as the payload format for
text conversation <xref target="RFC4103"/>, may send
packets so infrequently that the interval exceeds the NAT binding
timeouts.
</t>

<t>
Thirdly, if silence suppression is in use, long periods of silence may
cause media transmission to cease sufficiently long for NAT bindings
to time out.
</t>

<t>
For these reasons, the media packets themselves cannot be relied
upon. ICE defines a simple periodic keepalive utilizing STUN Binding
indications.  This makes its bandwidth requirements highly
predictable, and thus amenable to QoS reservations.
</t>

</section>

<section title="Why Prefer Peer Reflexive Candidates?">

<t>
<xref target="sec-prioritizing"/> describes procedures for computing
the priority of candidate based on its type and local
preferences. That section requires that the type preference for peer
reflexive candidates always be higher than server reflexive. Why is
that? The reason has to do with the security considerations in <xref
target="sec-security"/>. It is much easier for an attacker to cause an
agent to use a false server reflexive candidate than it is for an
attacker to cause an agent to use a false peer reflexive
candidate. Consequently, attacks against address gathering with
Binding requests are thwarted by ICE by preferring the peer reflexive
candidates.
</t>

</section>

<section title="Why Are Binding Indications Used for Keepalives?">

<t>
Media keepalives are described in <xref
target="sec-keepalives"/>. These keepalives make use of STUN when both
endpoints are ICE capable. However, rather than using a Binding
request transaction (which generates a response), the keepalives use
an Indication. Why is that?
</t>

<t>
The primary reason has to do with network QoS mechanisms. Once media
begins flowing, network elements will assume that the media stream has
a fairly regular structure, making use of periodic packets at fixed
intervals, with the possibility of jitter. If an agent is sending
media packets, and then receives a Binding request, it would need to
generate a response packet along with its media packets. This will
increase the actual bandwidth requirements for the 5-tuple carrying
the media packets, and introduce jitter in the delivery of those
packets. Analysis has shown that this is a concern in certain layer 2
access networks that use fairly tight packet schedulers for media.
</t>

<t>
Additionally, using a Binding Indication allows integrity to be
disabled, allowing for better performance. This is useful for
large-scale endpoints, such as PSTN gateways and SBCs.
</t>

</section>

</section>


<section anchor="sec-concheckbw" title="Connectivity Check Bandwidth">

<t>
The tables below show, for IPv4 and IPv6, the bandwidth required for
performing connectivity checks, using different Ta values (given in ms)
and different ufrag sizes (given in bytes).
</t>
<t>
The results were provided by Jusin Uberti (Google) 11th April 2016.
</t>
<figure title="Connectivity Check Bandwidth"
anchor="fig-concheckbw"><artwork>
<![CDATA[

IP version: IPv4
Packet len (bytes): 108 + ufrag
     |
  ms |     4     8    12    16
-----|------------------------
 500 | 1.86k 1.98k 2.11k 2.24k
 200 | 4.64k 4.96k 5.28k  5.6k
 100 | 9.28k 9.92k 10.6k 11.2k
  50 | 18.6k 19.8k 21.1k 22.4k
  20 | 46.4k 49.6k 52.8k 56.0k
  10 | 92.8k 99.2k  105k  112k
   5 |  185k  198k  211k  224k
   2 |  464k  496k  528k  560k
   1 |  928k  992k 1.06M 1.12M

IP version: IPv6
Packet len (bytes): 128 + ufrag
     |
  ms |     4     8    12    16
-----|------------------------
 500 | 2.18k  2.3k 2.43k 2.56k
 200 | 5.44k 5.76k 6.08k  6.4k
 100 | 10.9k 11.5k 12.2k 12.8k
  50 | 21.8k 23.0k 24.3k 25.6k
  20 | 54.4k 57.6k 60.8k 64.0k
  10 |  108k  115k  121k  128k
   5 |  217k  230k  243k  256k
   2 |  544k  576k  608k  640k
   1 | 1.09M 1.15M 1.22M 1.28M

]]></artwork></figure>


</section>

</back>
</rfc>
