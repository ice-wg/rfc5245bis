<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc='yes'?>
<?rfc tocdepth='5'?>
<?rfc symrefs='yes'?>

<?rfc compact='yes'?>
<?rfc subcompact='no'?>

<rfc ipr="pre5378Trust200902" category="std" obsoletes="5245"
     docName="draft-ietf-ice-rfc5245bis-latest"
>

    <front>
    <title abbrev="ICE">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</title>

    <author fullname="Ari Keranen" initials="A." surname="Keranen">
      <organization abbrev="Ericsson">Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <city>02420 Jorvas</city>
          <country>Finland</country>
        </postal>
        <email>ari.keranen@ericsson.com</email>
      </address>
    </author>

    <author fullname="Christer Holmberg" initials="C." surname="Holmberg">
      <organization abbrev="Ericsson">Ericsson</organization>
      <address>
        <postal>
          <street>Hirsalantie 11</street>
          <city>02420 Jorvas</city>
          <country>Finland</country>
        </postal>
        <email>christer.holmberg@ericsson.com</email>
      </address>
    </author>

    <author initials="J.R." surname="Rosenberg"
	    fullname="Jonathan Rosenberg">
      <organization>jdrosen.net</organization>
      <address>
	<postal>
	  <street/>
	  <city>Monmouth</city> <region>NJ</region>
	  <country>US</country>
	</postal>
	<email>jdrosen@jdrosen.net</email>
	<uri>http://www.jdrosen.net</uri>
      </address>
    </author>

        <date year="2018" />

        <area>ART</area>
        <workgroup>ICE</workgroup>
        <keyword>NAT</keyword>
        <abstract>
            <t>This document describes a protocol for Network Address
            Translator (NAT) traversal for UDP-based communication. This
            protocol is called Interactive Connectivity Establishment
            (ICE). ICE makes use of the Session Traversal Utilities
            for NAT (STUN) protocol and its extension, Traversal Using
            Relay NAT (TURN).</t>
	        <t>This document obsoletes RFC 5245.</t>
        </abstract>
    </front>

<middle>

<section title="Introduction">

<t>Protocols establishing communication sessions between peers typically
involve exchanging IP addresses and ports for the data sources and
sinks. However, this poses challenges when operated through Network Address
Translators (NATs) <xref target="RFC3235"/>. These protocols also seek to
create a data flow directly between participants, so that there is
no application layer intermediary between them.  This is done to
reduce data latency, decrease packet loss, and reduce the
operational costs of deploying the application.  However, this is
difficult to accomplish through NATs.  A full treatment of the reasons
for this is beyond the scope of this specification.  </t>

<t> Numerous solutions have been defined for allowing these protocols
to operate through NATs. These include Application Layer Gateways
(ALGs), the <xref target="RFC3303"> Middlebox Control Protocol</xref>,
the original <xref target="RFC3489">Simple Traversal of UDP Through
NAT (STUN)</xref> specification, and <xref target="RFC3102">Realm
Specific IP</xref> <xref target="RFC3103"/> along with session
description extensions needed to make them work, such as the Session
Description Protocol (SDP) <xref target="RFC4566"/> attribute for the
Real Time Control Protocol (RTCP) <xref
target="RFC3605"/>. Unfortunately, these techniques all have pros and
cons that make each one optimal in some network topologies, but a
poor choice in others. The result is that administrators and
implementers are making assumptions about the topologies of the
networks in which their solutions will be deployed. This introduces
complexity and brittleness into the system.</t>

<t> This specification defines Interactive Connectivity Establishment
(ICE) as a technique for NAT traversal for UDP-based data streams
(though ICE has been extended to handle other transport protocols,
such as TCP <xref target="RFC6544"/>). ICE works by exchanging a
multiplicity of IP addresses and ports which are then tested for
connectivity by peer-to-peer connectivity checks. The IP addresses and
ports are exchanged using ICE usage-specific mechanisms (for example, including in a
offer/answer exchange) and the connectivity checks are performed using
STUN <xref target="RFC5389"/>. ICE also makes use of Traversal Using Relays
around NAT (TURN) <xref target="RFC5766"/>, an extension to STUN.
Because ICE exchanges a multiplicity of IP addresses and ports for each media
stream, it also allows for address selection for multihomed and dual-
stack hosts. For this reason, RFC 5245 <xref target="RFC5245"/> deprecated 
the solutions previously defined in RFC 4091 <xref target="RFC4091"/> and 
RFC 4092 <xref target="RFC4092"/>.
</t>

<t> <xref target="sec-designmotivations"/> provides background information and 
motivations regarding the design decisions that were made when designing ICE.
</t>

</section>

<section title="Overview of ICE">

<t> In a typical ICE deployment, there are two endpoints (ICE agents) 
that want to communicate. Note that ICE is not intended for NAT traversal 
for the signaling protocol, which is assumed to be provided via another mechanism. 
ICE assumes that the agents are able to establish a signaling connection between
each other.
</t>
<t> 
Initially, the agents are ignorant of their own topologies. In particular, the 
agents may or may not be behind NATs (or multiple tiers of NATs). ICE allows the 
agents to discover enough information about their topologies to potentially find 
one or more paths by which they can establish a data session.
</t>

<t>
<xref target="fig-ice-ref-arch"/> shows a typical ICE deployment. The agents are 
labelled L and R. Both L and R are behind their own respective NATs though they may 
not be aware of it. The type of NAT and its properties are also unknown. L and R 
are capable of engaging in a candidate exchange process, whose purpose is to set
up a data session between L and R. Typically, this exchange will
occur through a signaling server (e.g., SIP proxy).
</t>

<t>
In addition to the agents, a signaling server, and NATs, ICE is
typically used in concert with STUN or TURN servers in the
network. Each agent can have its own STUN or TURN server, or they can
be the same.
</t>

<figure title="ICE Deployment Scenario" anchor="fig-ice-ref-arch"
align="center"><artwork>
<![CDATA[
                  +---------+
+--------+        |Signaling|         +--------+
| STUN   |        |Server   |         | STUN   |
| Server |        +---------+         | Server |
+--------+       /           \        +--------+
                /             \
               /               \
              / <- Signaling -> \
             /                   \
      +--------+               +--------+
      |  NAT   |               |  NAT   |
      +--------+               +--------+
        /                             \
       /                               \
   +-------+                       +-------+
   | Agent |                       | Agent |
   |   L   |                       |   R   |
   +-------+                       +-------+
]]></artwork></figure>


<t>The basic idea behind ICE is as follows: each agent has a variety
of candidate transport addresses (combination of IP address and port
for a particular transport protocol, which is always UDP in this
specification) it could use to communicate with the other agent. These
might include:
<list style="symbols">
<t>A transport address on a directly attached network interface</t>

<t>A translated transport address on the public side of a NAT (a "server
reflexive" address)</t>

<t>A transport address allocated from a TURN server (a "relayed
  address")</t>

</list>
</t>

<t>
Potentially, any of L's candidate transport addresses can be used to
communicate with any of R's candidate transport addresses. In
practice, however, many combinations will not work. For instance, if L
and R are both behind NATs, their directly attached interface
addresses are unlikely to be able to communicate directly (this is why
ICE is needed, after all!). The purpose of ICE is to discover which
pairs of addresses will work. The way that ICE does this is to
systematically try all possible pairs (in a carefully sorted order)
until it finds one or more that work.
</t>

<section title="Gathering Candidates">
<t>
In order to execute ICE, an ICE agent identifies and gathers one or more
address candidates. A candidate has a transport address -- a combination of IP
address and port for a particular transport protocol (with only UDP
specified here). There are different types of candidates, some
derived from physical or logical network interfaces, others
discoverable via STUN and TURN. 
</t>
<t>
The first category of candidates are those with a transport address obtained directly 
from a local interface. Such a candidate is called a host candidate. 
The local interface could be Ethernet or WiFi, or it could be one that 
is obtained through a tunnel mechanism, such as a Virtual Private Network 
(VPN) or Mobile IP (MIP). In all cases, such a network interface appears 
to the agent as a local interface from which ports (and thus candidates) 
can be allocated.
</t>

<t> Next, the agent uses STUN or TURN to obtain additional
candidates. These come in two flavors: translated addresses on the
public side of a NAT (server reflexive candidates) and addresses on
TURN servers (relayed candidates). When TURN servers are utilized,
both types of candidates are obtained from the TURN server. If only
STUN servers are utilized, only server reflexive candidates are
obtained from them.  The relationship of these candidates to the host
candidate is shown in <xref target="fig-address-types"/>.  In this
figure, both types of candidates are discovered using TURN. In the
figure, the notation X:x means IP address X and UDP port x.
</t>

<figure title="Candidate Relationships" anchor="fig-address-types">
<artwork>
<![CDATA[

              To Internet

                  |
                  |
                  |  /------------  Relayed
              Y:y | /               Address
              +--------+
              |        |
              |  TURN  |
              | Server |
              |        |
              +--------+
                  |
                  |
                  | /------------  Server
           X1':x1'|/               Reflexive
            +------------+         Address
            |    NAT     |
            +------------+
                  |
                  | /------------  Local
              X:x |/               Address
              +--------+
              |        |
              | Agent  |
              |        |
              +--------+

]]></artwork></figure>

<t> When the agent sends a TURN Allocate request from IP address and
port X:x, the NAT (assuming there is one) will create a binding
X1':x1', mapping this server reflexive candidate to the host candidate
X:x. Outgoing packets sent from the host candidate will be translated
by the NAT to the server reflexive candidate. Incoming packets sent
to the server reflexive candidate will be translated by the NAT to the
host candidate and forwarded to the agent. The host candidate
associated with a given server reflexive candidate is the BASE.
</t>

<t><list style="empty">
<t>Note: "Base" refers to the address an agent sends from for a particular
candidate. Thus, as a degenerate case, host candidates also have a base,
but it's the same as the host candidate.
</t></list></t>

<t>
When there are multiple NATs between the agent and the TURN server,
the TURN request will create a binding on each NAT, but only the
outermost server reflexive candidate (the one nearest the TURN server)
will be discovered by the agent. If the agent is not behind a NAT,
then the base candidate will be the same as the server reflexive
candidate and the server reflexive candidate is redundant and will be
eliminated.
</t>

<t>
The Allocate request then arrives at the TURN server. The TURN server
allocates a port y from its local IP address Y, and generates an
Allocate response, informing the agent of this relayed candidate. The
TURN server also informs the agent of the server reflexive candidate,
X1':x1' by copying the source transport address of the Allocate
request into the Allocate response. The TURN server acts as a packet
relay, forwarding traffic between L and R. In order to send traffic to
L, R sends traffic to the TURN server at Y:y, and the TURN server
forwards that to X1':x1', which passes through the NAT where it is
mapped to X:x and delivered to L.
</t>

<t>
When only STUN servers are utilized, the agent sends a STUN Binding
request <xref target="RFC5389"/> to its STUN server. The STUN server
will inform the agent of the server reflexive candidate X1':x1' by
copying the source transport address of the Binding request into the
Binding response.
</t>

</section>

<section title="Connectivity Checks">
<t>
Once L has gathered all of its candidates, it orders them in highest
to lowest-priority and sends them to R over the signaling
channel. When R receives the candidates from L, it performs the same
gathering process and responds with its own list of candidates. At the
end of this process, each ICE agent has a complete list of both its
candidates and its peer's candidates. It pairs them up, resulting in
candidate pairs. To see which pairs work, each agent schedules a
series of connectivity checks. Each check is a STUN request/response transaction
that the client will perform on a particular candidate pair by sending
a STUN request from the local candidate to the remote candidate.
</t>

<t>
The basic principle of the connectivity checks is simple:
<list style="numbers">
<t>Sort the candidate pairs in priority order.</t>
<t>Send checks on each candidate pair in priority order.</t>
<t>Acknowledge checks received from the other agent.</t>
</list>
With both agents performing a check on a candidate pair, the result is
a 4-way handshake:
</t>

<figure title="Basic Connectivity Check"
anchor="fig:connectivity-checks" align="center"><artwork>
<![CDATA[
L                        R
-                        -
STUN request ->             \  L's
          <- STUN response  /  check

           <- STUN request  \  R's
STUN response ->            /  check
]]></artwork></figure>

<t>
It is important to note that the STUN requests are sent to and from
the exact same IP addresses and ports that will be used for data
(e.g., RTP, RTCP, or other protocols). Consequently, agents
demultiplex STUN and data using the contents of the packets, rather
than the port on which they are received.
</t>

<t>
Because a STUN Binding request is used for the connectivity check, the
STUN Binding response will contain the agent's translated transport
address on the public side of any NATs between the agent and its
peer. If this transport address is different from that of other candidates the
agent already learned, it represents a new candidate (peer reflexive candidate), 
which then gets tested by ICE just the same as any other candidate.
</t>

<t>
Because the algorithm above searches all candidate pairs, if a working
pair exists it will eventually find it no matter what order the
candidates are tried in. In order to produce faster (and better)
results, the candidates are sorted in a specified order. The resulting
list of sorted candidate pairs is called the check list.
</t>

<t>
The agent works through the check list by sending a STUN request for
the next candidate pair on the list periodically. These are called
"ordinary checks". When a STUN transaction succeeds, one or more
candidate pairs will become so called valid pairs, and will be added
to a candidate pair list called the valid list.
</t>

<t>
As an optimization, as soon as R gets L's check message, R schedules
a connectivity check message to be sent to L on the same candidate
pair. This is called a "triggered check", and accelerates the process
of finding valid pairs.
</t>

<t>
At the end of this handshake, both L and R know that they can
send (and receive) messages end-to-end in both directions.
</t>

<t>
In general, the priority algorithm is designed so that candidates of
similar type get similar priorities and so that more direct routes
(that is, routes without data relays or NATs) are preferred over
indirect routes (routes with data relays or NATs).
Within those guidelines, however, agents have a fair amount of
discretion about how to tune their algorithms.
</t>

<t>
A data stream might consist of multiple components (pieces of a data
stream that require their own set of candidates, e.g., RTP and RTCP).
</t>

</section>


<section title="Nominating Candidate Pairs And Concluding ICE">
<t>
ICE assigns one of the ICE agents in the role of the
controlling agent, and the other of the controlled agent. For each 
component of a data stream, the controlling agent nominates
a valid pair (from the valid list) to be used for data.
The exact timing of the nomination is based on local policy.
</t>
<t>
When nominating, the controlling agent lets the checks continue
until at least one valid pair for each component of a 
data stream is found and then picks a valid pair and sends a 
STUN request on the valid pair, using an attribute 
to indicate to the controlled peer that it has nominated the pair.
This is shown in <xref target="fig-regular-select"/>.
</t>

<figure title="Nomination"
anchor="fig-regular-select" align="center"><artwork>
<![CDATA[
L                        R
-                        -
STUN request ->             \  L's
          <- STUN response  /  check

           <- STUN request  \  R's
STUN response ->            /  check

STUN request + attribute -> \  L's
          <- STUN response  /  check

]]></artwork></figure>

<t>
Once the controlled agent receives the STUN request with the attribute, it
will check (unless the check has already been done) the same pair.
If the transactions above succeed, the agents will set the nominated flag
for the pairs, and will cancel any future checks for that component 
of the data stream. Once an agent has set the nominated flag for each component
of a data stream, the pairs become the selected pairs. After that, only the selected
pairs will be used for sending and receiving data associated with that data stream.
</t>
</section>

<section title="ICE Restart">
<t>
Once ICE is concluded, it can be restarted at any time for one or all
of the data streams by either ICE agent. This is done by sending updated
candidate information indicating a restart.
</t>
</section>

<section title="Lite Implementations">
<t>
Certain ICE agents will always be connected to the public
Internet and have a public IP address at which it can receive packets
from any correspondent. To make it easier for these devices to support
ICE, ICE defines a special type of implementation called lite (in
contrast to the normal full implementation). Lite agents only use 
host candidates and do not generate connectivity checks or run
the state machines, though they need to be able to respond to
connectivity checks.
</t>
</section>
</section>

<section title="ICE Usage">

<t>This document specifies generic use of ICE with protocols that
provide means to exchange candidate information between the ICE agents.
The specific details (i.e., how to encode candidate information and
the actual candidate exchange process) for different protocols
using ICE (referred to as "using protocol") are described in separate 
usage documents. 
</t>
<t>
One mechanism for agents to exchange the candidate information by using
<xref target="RFC3264"/> based Offer/Answer semantics as part of the SIP
<xref target="RFC3261"/> protocol <xref target="I-D.ietf-mmusic-ice-sip-sdp"/>.
</t>
<t>
<xref target="RFC7825"/> defines an ICE usage for the Real-Time Streaming 
Protocol (RTSP). Note, however, that the ICE usage is based on RFC 5245.
</t>
</section>

<section title="Terminology">

<t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as described in
<xref target="RFC2119">RFC 2119</xref>.  </t>

<t>
Readers need to be familiar with the terminology defined in 
<xref target="RFC5389"/>, and NAT Behavioral requirements
for UDP <xref target="RFC4787"/>.
</t>

<t>
This specification makes use of the following additional terminology:
</t>

<t><list style="hanging">

<t hangText="ICE Session:">
An ICE session consists of all ICE-related actions starting with the
candidate gathering, followed by the interactions (candidate exchange,
connectivity checks, nominations and keep-alives) between the ICE agents
until all the candidates are released or ICE-restart is triggered.</t>

<t hangText="ICE Agent, Agent:">
An ICE agent (sometimes simply referred to as an agent) is the protocol 
implementation involved in the ICE candidate exchange. There are two agents 
involved in a typical candidate exchange. </t>

<t hangText= "Initiating Peer, Initiating Agent, Initiator:">
An initiating agent is an ICE agent that initiates the ICE candidate exchange
process. </t>

<t hangText="Responding Peer, Responding Agent, Responder:">
A responding agent is an ICE agent that receives
and responds to the candidate exchange process initiated by the
initiating agent. </t>

<t hangText="ICE Candidate Exchange, Candidate Exchange:">
The process where the ICE agents exchange information (e.g.,
candidates and passwords) that is needed to perform ICE.  <xref
target="RFC3264"/> Offer/Answer with SDP encoding is one example of a
protocol that can be used for exchanging the candidate
information. </t>

<t hangText="Peer:">
From the perspective of one of the ICE agents in a session, its peer is
the other agent. Specifically, from the perspective of the initiating
agent, the peer is the responding agent.  From the perspective of the
responding agent, the peer is the initiating agent. </t>

<t hangText="Transport Address:"> The combination of an IP address and
transport protocol (such as UDP or TCP) port.</t>

<t hangText="Data, Data Stream, Data Session:"> When ICE is used to
setup data sessions, the data is transported using some protocol.
Media is usually transported over RTP, 
composed of a stream of RTP packets. Data session refers to data packets
that are exchanged between the peer on the path created and tested with ICE.</t>

<t hangText="Candidate, Candidate Information:"> A transport address
that is a potential point of contact for receipt of data. Candidates
also have properties -- their type (server reflexive, relayed, or
host), priority, foundation, and base.
</t>

<t hangText="Component:"> A component is a piece of a data stream.
A data stream may require multiple components, each of which has to
work in order for the data stream as a whole to work. For RTP/RTCP data streams,
unless RTP and RTCP are multiplexed in the same port, there 
are two components per data stream -- one for RTP, and one for RTCP.
A component has a candidate pair, which cannot be used by other components.</t>

<t hangText="Host Candidate:"> A candidate obtained by binding to a
specific port from an IP address on the host. This includes IP
addresses on physical interfaces and logical ones, such as ones
obtained through Virtual Private Networks (VPNs).
</t>

<t hangText="Server Reflexive Candidate:"> A candidate whose IP
address and port are a binding allocated by a NAT for an ICE agent when it
sent a packet through the NAT to a server, such as a STUN server.
</t>

<t hangText="Peer Reflexive Candidate:"> A candidate whose IP
address and port are a binding allocated by a NAT for an ICE agent when it
sent a packet through the NAT to its peer.
</t>

<t hangText="Relayed Candidate:"> A candidate obtained from a relay
server, such as a TURN server.
</t>

<t hangText="Base:"> The transport address that an ICE agent sends from
for a particular candidate. For host, server reflexive and peer reflexive
candidates the base is the same as the host candidate. For relayed
candidates the base is the same as the relayed candidate (i.e., 
the transport address used by the TURN server to send from).
</t>

<t hangText="Related Address and Port:"> 
A transport address related to a candidate, useful for diagnostics and other purposes.
If a candidate is server or peer reflexive, the related address and port is equal to the base
for that server or peer reflexive candidate. If the candidate is relayed, the related address 
and port is equal to the mapped address in the Allocate response that provided the client 
with that relayed candidate. If the candidate is a host candidate, the related address and port 
is identical to the host candidate.
</t>

<t hangText="Foundation:"> An arbitrary string used in the freezing
algorithm to group similar candidates.  Is the same for two candidates
that have the same type, base IP address, protocol (UDP, TCP, etc.),
and STUN or TURN server. If any of these are different, then the
foundation will be different.
</t>

<t hangText="Local Candidate:">A candidate that an ICE agent has obtained
and may send to its peer.
</t>

<t hangText="Remote Candidate:">A candidate that an ICE agent received
from its peer.
</t>

<t hangText="Default Destination/Candidate:"> The default destination
for a component of a data stream is the transport address that would
be used by an ICE agent that is not ICE-aware. A default candidate for a
component is one whose transport address matches the default
destination for that component.
</t>

<t hangText="Candidate Pair:"> A pair of a local candidate
and a remote candidate.
</t>

<t hangText="Check, Connectivity Check, STUN Check:"> A STUN Binding
request for the purposes of verifying connectivity. A
check is sent from the base of the local candidate 
to the remote candidate of a candidate pair.
</t>

<t hangText="Check List:"> An ordered set of candidate pairs that an
ICE agent will use to generate checks.
</t>

<t hangText="Ordinary Check:"> A connectivity check generated by an
ICE agent as a consequence of a timer that fires periodically, instructing
it to send a check.
</t>

<t hangText="Triggered Check:"> A connectivity check generated as a
consequence of the receipt of a connectivity check from the peer.
</t>

<t hangText="Valid Pair:"> A candidate pair whose 
local candidate equals the mapped address of a successful connectivity 
check response, and whose remote candidate equals the destination address to 
which the connectivity check request was sent.
</t>
 
<t hangText="Valid List:"> An ordered set of candidate pairs for a
data stream that have been validated by a successful STUN
transaction.
</t>

<t hangText="Check List Set:"> The ordered list of all check lists.
The order is determined by each ICE usage.
</t>


<t hangText="Full Implementation:"> An ICE implementation that
performs the complete set of functionality defined by this
specification.
</t>

<t hangText="Lite Implementation:"> An ICE implementation that omits certain
functions, implementing only as much as is necessary for a peer
implementation that is full to gain the benefits of ICE. Lite
implementations do not maintain any of the state machines and do not
generate connectivity checks.
</t>

<t hangText="Controlling Agent:"> The ICE agent that nominates a
candidate pair. In any session, one agent is always controlling. The
other is the controlled agent.
</t>

<t hangText="Controlled Agent:"> The ICE agent that waits for the
controlling agent to nominate a candidate pair.
</t>

<t hangText="Nomination:"> The process of the controlling agent
indicating to the controlled agent which candidate pair the ICE
agents will use for sending and receiving data. The nomination
process defined in this specification was referred to "regular nomination"
in RFC 5245. The nomination process that was referred
to "aggressive nomination" in RFC 5245 has been deprecated in
this specification.
</t>

<t hangText="Nominated, Nominated Flag:"> Once the nomination of a 
candidate pair has succeeded, the candidate pair has become nominated, 
and the value of its nominated flag is set to true.
</t>

<t hangText="Selected Pair, Selected Candidate Pair:"> The candidate
pair used for sending and receiving data for a component of a data stream is
referred to as the selected pair. Before selected pairs have been produced for a data stream, 
any valid pair associated with a component of a data stream
can be used for sending and receiving data for the component.
Once there are nominated pairs for each component of a data
stream, the nominated pairs become the selected pairs for the data stream. 
The candidates associated with the selected pairs are referred to as selected candidates.
</t>

<t hangText="Using Protocol, ICE Usage:"> The protocol that uses ICE
for NAT traversal. A usage specification defines the protocol-specific
details on how the procedures defined here are applied to that
protocol. </t>

<t hangText="Timer Ta:"> The timer for generating new STUN or TURN transactions.</t>

<t hangText="Timer RTO (Retransmission Timout):"> The retransmission timer for a given STUN or TURN transaction.</t>

<t hangText="Timer HTO (Handshake Timeout):"> The timeout timer for a given STUN or TURN transaction.</t>

</list></t>
<t>
NOTE: When STUN and TURN are used with ICE, timer HTO is used instead of timer Ti <xref target="RFC3264"/> as 
transaction timeout timer.
</t>
</section>


<section anchor="sec-gathering_exchange" title="ICE Candidate Gathering and Exchange">

<t>
As part of ICE processing, both the initiating and responding agents
gather candidates, prioritize and eliminate redundant candidates,  
and exchange candidate information with the peer as defined by the 
Usage Protocol (ICE Usage). Specifics of the candidate encoding 
mechanism and the semantics of candidate information exchange is out 
of scope of this specification.
</t>

<section anchor="sec-full-impl-reqs" title="Full Implementation">

<section anchor="sec-gathering" title="Gathering Candidates">

<t>
An ICE agent gathers candidates when it believes that communication is
imminent. An initiating agent can do this based on a user interface
cue, or based on an explicit request to initiate a session.  Every
candidate has a transport address. It also has a type and a base.
Four types are defined and gathered by this specification -- host
candidates, server reflexive candidates, peer reflexive candidates,
and relayed candidates.  The server reflexive candidates are gathered
using STUN or TURN, and relayed candidates are obtained through TURN.
Peer reflexive candidates are obtained in later phases of ICE, as a
consequence of connectivity checks.
</t>

<t>
The process for gathering candidates at the responding agent is
identical to the process for the initiating agent. It is RECOMMENDED
that the responding agent begins this process immediately on receipt
of the candidate information, prior to alerting the user of the
application associated with the ICE session.
</t>

<section title="Host Candidates">

<t> Host candidates are obtained by binding to ports on an IP address
attached to an interface (physical or virtual, including VPN
interfaces) on the host.
</t>

<t>For each component of each data stream the ICE agent wishes to use,
the agent SHOULD obtain a candidate on each IP address that the host
has, with the exceptions listed below. The agent
obtains each candidate by binding to a UDP port on the specific IP
address. A host candidate (and indeed every candidate) is always
associated with a specific component for which it is a candidate. </t>

<t> Each component has an ID assigned to it, called the component ID.
For RTP/RTCP data streams, unless both RTP and RTCP are multiplexed
in the same UDP port (RTP/RTCP multiplexing), the RTP itself has a
component ID of 1, and RTCP a component ID of 2. In case of RTP/RTCP
multiplexing, a component ID of 1 is used for both RTP and RTCP.</t>

<t>When candidates are obtained, unless the agent knows for sure that
RTP/RTCP multiplexing will be used (i.e., the agent knows that the
other agent also supports, and is willing to use, RTP/RTCP
multiplexing), or unless the agent only supports RTP/RTCP
multiplexing, the agent MUST obtain a separate candidate for RTCP. If
an agent has obtained a candidate for RTCP, and ends up using RTP/RTCP
multiplexing, the agent does not need to perform connectivity checks
on the RTCP candidate.  Absence of a component ID 2 as such does not
imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is
not used. </t>

<t>If an agent is using separate candidates for RTP and RTCP, it will
end up with 2*K host candidates if an agent has K IP addresses.</t>

<t>Note that the responding agent, when obtaining its candidates, will
typically know if the other agent supports RTP/RTCP multiplexing, in
which case it will not need to obtain a separate candidate for
RTCP. However, absence of a component ID 2 as such does not imply use
of RTCP/RTP multiplexing, as it could also mean that RTCP is not
used. </t>

<t> For uses other than RTP/RTCP streams, use of multiple components is
discouraged, since using them increases the complexity of ICE
processing. If multiple components are needed, the component IDs
SHOULD start with 1 and increase by 1 for each component.
</t>
		
<t>		
The base for each host candidate is set to the candidate itself.		
</t>		

<t> The host candidates are gathered from all IP addresses with the
following exceptions:

  <list style="symbols">

    <t> Addresses from a loopback interface MUST NOT be included in
    the candidate addresses. </t>

    <t> Deprecated IPv4-compatible IPv6 addresses <xref
    target="RFC4291"/> and IPv6 site-local unicast addresses <xref
    target="RFC3879"/> MUST NOT be included in the address
    candidates. </t>

    <t> IPv4-mapped IPv6 addresses SHOULD NOT be included in the
    address candidates unless the application using ICE does not
    support IPv4 (i.e., is an IPv6-only application <xref
    target="RFC4038"/>). </t>

    <t> If one or more host candidates corresponding to an IPv6
    address generated using a mechanism that prevents location
    tracking <xref target="RFC7721"/> are
    gathered, host candidates corresponding to IPv6 addresses that do
    allow location tracking, that are configured on the same
    interface, and are part of the same network prefix MUST NOT be
    gathered.</t>

    <t>If one or more host candidates corresponding to an IPv6 
    address generated using a mechanism that prevents location 
    tracking <xref target="RFC7721"/> are gathered, host candidates 
    corresponding to IPv6 addresses that do allow location tracking 
    that are configured on the same interface and are part of the 
    same network prefix MUST NOT be gathered; and host candidates 
    corresponding to IPv6 link-local addresses <xref target="RFC4291"/>
    MUST NOT be gathered.</t>
  </list>
</t>

<t>The IPv6 default address selection specification <xref target="RFC6724"/> 
specifies that temporary addresses <xref target="RFC4941"/> are to be 
preferred over permanent addresses.</t>

</section>

<section title="Server Reflexive and Relayed Candidates">

<t>
An ICE agent SHOULD gather server reflexive and relayed candidates.
However, use of STUN and TURN servers may be unnecessary in certain networks
and use of TURN servers may be expensive, so some deployments may
elect not to use them. If an agent does not gather server reflexive
or relayed candidates, it is RECOMMENDED that the functionality be
implemented and just disabled through configuration, so that it can be
re-enabled through configuration if conditions change in the future.
</t>

<t>
The agent pairs each host candidate with the STUN or TURN servers
with which it is configured or has discovered by some means. 
It is RECOMMENDED that a domain name be
configured, and the DNS procedures in <xref target="RFC5389"/> (using
SRV records with the "stun" service) be used to discover the STUN
server, and the DNS procedures in <xref target="RFC5766"/> (using SRV
records with the "turn" service) be used to discover the TURN server.
</t>

<t>
When multiple STUN or TURN servers are available (or when they are
learned through DNS records and multiple results are returned), the
agent MAY gather candidates for all of them and SHOULD gather
candidates for at least one of them (one STUN server and one TURN
server).  It does so by pairing host candidates with STUN or TURN
servers and, for each pair, the agent sends a Binding or Allocate
request to the server from the host candidate. Binding requests to a
STUN server are not authenticated, and any ALTERNATE-SERVER attribute
in a response is ignored. Agents MUST support the backwards
compatibility mode for the Binding request defined in <xref
target="RFC5389"/>. Allocate requests SHOULD be authenticated using a
long-term credential obtained by the client through some other means.
</t>

<t>
The gathering process is controlled using a timer, Ta.
Every time Ta expires the agent can generate another new
STUN or TURN transaction. This transaction can either be a retry of a
previous transaction that failed with a recoverable error (such as
authentication failure), or a transaction for a new host candidate and
STUN or TURN server pair. The agent SHOULD NOT generate transactions
more frequently than one every time Ta expires. See <xref
target="sec-ta"/> for guidance on how to set Ta and the STUN
retransmit timer, RTO.
</t>

<t>The agent will receive a Binding or Allocate response. A successful
Allocate response will provide the agent with a server reflexive
candidate (obtained from the mapped address) and a relayed candidate
in the XOR-RELAYED-ADDRESS attribute. If the Allocate request is
rejected because the server lacks resources to fulfill it, the agent
SHOULD instead send a Binding request to obtain a server reflexive
candidate. A Binding response will provide the agent with only a
server reflexive candidate (also obtained from the mapped
address). The base of the server reflexive candidate is the host
candidate from which the Allocate or Binding request was sent. The
base of a relayed candidate is that candidate itself. If a relayed
candidate is identical to a host candidate (which can happen in rare
cases), the relayed candidate MUST be discarded.
</t>

<t>
If an IPv6-only agent is in a network that utilizes NAT64 <xref
target="RFC6146"/> and DNS64 <xref target="RFC6147"/> technologies, it
may also gather IPv4 server reflexive and/or relayed candidates from
IPv4-only STUN or TURN servers.  IPv6-only agents SHOULD also utilize
IPv6 prefix discovery <xref target="RFC7050"/> to discover the IPv6
prefix used by NAT64 (if any) and generate server reflexive candidates
for each IPv6-only interface accordingly.  The NAT64 server reflexive
candidates are prioritized like IPv4 server reflexive candidates.
</t>

</section>

<section anchor="sec-computing-foundations" title="Computing Foundations">

<t>
The ICE agent assigns each candidate a foundation. Two candidates
have the same foundation when all of the following are true:
</t>

<t><list style="symbols">

<t>They have the same type (host, relayed,
server reflexive, or peer reflexive).</t>

<t>Their bases have the
same IP address (the ports can be different).</t>

<t>For reflexive and relayed candidates, the STUN or TURN servers used
to obtain them have the same IP address (the IP address used by the
agent to contact the STUN or TURN server).
</t>

<t>They were obtained using the same transport protocol (TCP, UDP).
</t>

</list></t>

<t> Similarly, two candidates have different foundations if their
types are different, their bases have different IP addresses, the STUN
or TURN servers used to obtain them have different IP addresses
(the IP addresses used by the agent to contact the STUN or TURN server), 
or their transport protocols are different.
</t>

</section>

<section title="Keeping Candidates Alive">

<t>
Once server reflexive and relayed candidates are allocated, they MUST
be kept alive until ICE processing has completed, as described in
<xref target="sec-freeing"/>. For server reflexive candidates learned
through a Binding request, the bindings MUST be kept alive by
additional Binding requests to the server. Refreshes for allocations
are done using the Refresh transaction, as described in <xref
target="RFC5766"/>. The Refresh requests will also refresh the server
reflexive candidate.
</t>
<t>
Host candidates do not time out, but the candidate addresses may
change or disappear for a number of reasons. An ICE agent SHOULD
monitor the interfaces it uses, invalidate candidates whose base has
gone away, and acquire new candidates as appropriate when new
IP addresses (on new or currently used interfaces) appear.
</t>

</section>

<!-- end gathering -->
</section>

<section anchor="sec-prioritizing" title="Prioritizing Candidates">
<t>
The prioritization process results in the assignment of a priority to
each candidate. Each candidate for a data stream MUST have a unique
priority that MUST be a positive integer between 1 and (2**31 - 1).
This priority will be used by ICE to determine the order of the
connectivity checks and the relative preference for candidates.
Higher priority values give more priority over lower values.
</t>

<t>
An ICE agent SHOULD compute this priority using the formula in <xref
target="sec-rec-form"/> and choose its parameters using the guidelines
in <xref target="sec-guidelines"/>. If an agent elects to use a
different formula, ICE may take longer to converge since the agents
will not be coordinated in their checks.
</t>

<t>
The process for prioritizing candidates is common across the
initiating and the responding agent.
</t>

<section anchor="sec-rec-form" title="Recommended Formula">

<t>The recommended formula combines a preference for the candidate
type (server reflexive, peer reflexive, relayed, and host), a
preference for the IP address for which the candidate was obtained, and
component ID using the following formula:
</t>

<figure><artwork>
<![CDATA[
priority = (2^24)*(type preference) +
           (2^8)*(local preference) +
           (2^0)*(256 - component ID)

]]></artwork></figure>

<t>
The type preference MUST be an integer from 0 (lowest preference) to
126 (highest preference) inclusive and MUST be identical for all
candidates of the same type and MUST be different for candidates of
different types. The type preference for peer reflexive candidates
MUST be higher than that of server reflexive candidates.
Setting the value to 0 means that candidates of this type will only 
be used as a last resort. Note that candidates
gathered based on the procedures of <xref target="sec-gathering"/>
will never be peer reflexive candidates; candidates of these type are
learned from the connectivity checks performed by ICE.
</t>

<t>The local preference MUST be an integer from 0 (lowest preference) 
to 65535 (highest preference) inclusive. When there is only a single IP
address, this value SHOULD be set to 65535.  If there
are multiple candidates for a particular component for a particular
data stream that have the same type, the local preference MUST be
unique for each one. If an ICE agent is dual-stack, the local preference
SHOULD be set according to the current best practice described in <xref
target="I-D.ietf-ice-dualstack-fairness"/>.</t>


<t>The component ID MUST be an integer between 1 and 256 inclusive.</t>


</section>

<section anchor="sec-guidelines" title="Guidelines for Choosing Type and Local Preferences">

<t>The RECOMMENDED values for type preferences are 126 for host
candidates, 110 for peer reflexive candidates, 100 for server
reflexive candidates, and 0 for relayed candidates.</t>

<t>If an ICE agent is multihomed and has multiple IP
addresses, the recommendations in <xref target=
"I-D.ietf-ice-dualstack-fairness"/> SHOULD be followed.  If multiple
TURN servers are used, local priorities for the candidates obtained
from the TURN servers are chosen in a similar fashion as for
multihomed local candidates: the local preference value is used to
indicate a preference among different servers but the preference MUST
be unique for each one.</t>

<t>When choosing type preferences, agents may take into account
factors such as latency, packet loss, cost, network topology,
security, privacy, and others.</t>


</section>

<!-- end prioritization -->
</section>

<section anchor="sec-el-red" title="Eliminating Redundant Candidates">

<t>
Next, the ICE agents (initiating and responding) eliminate redundant
candidates. Two candidates
can have the same transport address yet have different bases, and
these would not be considered redundant. Frequently, a server
reflexive candidate and a host candidate will be redundant when the
agent is not behind a NAT.  A candidate is redundant if and only if its transport
address and base equal those of another candidate.  The agent SHOULD
eliminate the redundant candidate with the lower priority.
</t>
</section>
<!-- end full implementation -->
</section>

<section anchor="sec-offer-lite" title="Lite Implementation Procedures">

<t>
Lite implementations only utilize host candidates. For each IP address, independent
of IP address family, there MUST be zero or one candidate. With the lite implementation, 
ICE cannot be used to dynamically choose amongst candidates. Therefore, including more 
than one candidate from a particular IP address family is NOT RECOMMENDED, since only 
a connectivity check can truly determine whether to use one address or the other. Instead 
agents that have multiple public IP addresses are RECOMMENDED to run full ICE implementations 
to ensure the best usage of its addresses.
</t>

<t>Each component has an ID assigned to it, called the component ID.
For RTP/RTCP data streams, unless RTCP is multiplexed in the same
port with RTP, the RTP itself has a component ID of 1, and RTCP a
component ID of 2. If an agent is using RTCP without multiplexing, it
MUST obtain candidates for it.  However, absence of a component ID 2
as such does not imply use of RTCP/RTP multiplexing, as it could also
mean that RTCP is not used.</t>

<t>
Each candidate is assigned a foundation. The foundation MUST be
different for two candidates allocated from different IP addresses,
and MUST be the same otherwise. A simple integer that increments for
each IP address will suffice. In addition, each candidate MUST be
assigned a unique priority amongst all candidates for the same data
stream. If the formula in <xref target="sec-rec-form"/> is used to
calculate the priority, the type preference value SHOULD be set to 126.
If a host is v4-only, the local preference value SHOULD be set to 65535. If a
host is v6 or dual-stack, the local preference value SHOULD be set to the 
precedence value for IP addresses described in RFC 6724 <xref target="RFC6724"/>.
</t>

<t>
Next, an agent chooses a default candidate for each component of each
data stream. If a host is IPv4-only, there would only be one
candidate for each component of each data stream, and therefore that
candidate is the default. If a host is IPv6-only, the default candidate 
would typically be a globally scoped IPv6 address. Dual-stack hosts SHOULD 
allow configuration of whether IPv4 or IPv6 is used for the default candidate, 
and the configuration needs to be based on which one its administrator believes 
has a higher chance of success in the current network environment.</t>

<t>
The procedures in this section are common across the initiating and
responding agents.
</t>

</section>

<section anchor="sec-encoding" title="Exchanging Candidate Information">

<t>ICE agents (initiating and responding) need the following information
about candidates to be exchanged. Each ICE usage MUST define how the information
is exchanged with the using protocol. This section describes the information that
needs to be exchanged.
</t>

<t><list style="hanging">

<t hangText="Candidates: ">One or more candidates.  For each
candidate:
</t>

<t>
  <list style="hanging">
    <t hangText="Address:"> The IP address and transport
    protocol port of the candidate. </t>

    <t hangText="Transport:"> The transport protocol of the candidate.
    This MAY be omitted if the using protocol only runs over
    a single transport protocol. </t>

    <t hangText="Foundation:"> A sequence of up to 32 characters.</t>

    <t hangText="Component ID:"> The component ID of the candidate.
    This MAY be omitted if the using protocol does not use the concept
    of components.</t>

    <t hangText="Priority:">The 32-bit priority of the candidate.</t>

    <t hangText="Type:">The type of the candidate.</t>

    <t hangText="Related Address and Port:">The related IP address and
    port of the candidate. These MAY be omitted or set to invalid
    values if the agent does not want to reveal them, e.g., for
    privacy reasons.</t>

    <t hangText="Extensibility Parameters:"> The using protocol might
    define means for adding new per-candidate ICE parameters in
    the future.</t>
  </list>
</t>

<t hangText="Lite or Full: ">Whether the agent is a lite agent or full
agent.</t>

<t hangText="Connectivity check pacing value:">The pacing value for
connectivity checks that the agent wishes to use. This MAY be omitted if
the agent wishes to use a defined default value.</t>

<t hangText="Username Fragment and Password:"> Values used to perform connectivity
checks. The values MUST be unguessable, with at least 128 bits of random
number generator output used to generate the password, and at least 24
bits output to generate the username fragment.</t>

<t hangText="Extensions:"> New media-stream or session-level 
attributes (ice-options).
</t>

</list></t>

<t>
If the using protocol is vulnerable to, and able to detect, ICE mismatch
(<xref target="sec-verify"/>), a way is needed for the detecting agent to 
convey this information to its peer. It is a boolean flag.
</t>

<t>
The using protocol may (or may not) need to deal with backwards
compatibility with older implementations that do not support ICE. 
If a fallback mechanism to non-ICE is supported is being used, 
then presumably the using protocol provides a way of conveying the 
default candidate (its IP address and port) in addition to the 
ICE parameters.
</t>

<t>
Once an agent has sent its candidate information, it MUST be
prepared to receive both STUN and data packets on each candidate. As
discussed in <xref target="sec-send-media"/>, data packets can be
sent to a candidate prior to its appearance as the default destination
for data.
</t>

</section>

<section anchor="sec-verify" title="ICE Mismatch">
<t>
Certain middleboxes, such as ALGs, can alter signaling
information in ways that break ICE break ICE (for example, by rewriting 
IP addresses in SDP). This is referred to as ICE mismatch.
If the using protocol is vulnerable to ICE mismatch, the responding 
agent needs to be able to detect it and inform the peer ICE agent 
about the ICE mismatch. 
</t>
<t>
Each using protocol needs to define whether the using protocol is vulnerable
to ICE mismatch, how ICE mismatch is detected, and whether specific 
actions need to be taken when ICE mismatch is detected.
</t>
</section>


</section>

<section anchor="sec-candidate_proc" title="ICE Candidate Processing">

<t>
Once an ICE agent has gathered its candidates and exchanged candidates with its peer
(<xref target="sec-gathering_exchange"/>), it will determine its own role. In addition,
full implementations will form check lists, and begin performing connectivity checks with the peer.
</t>

<section anchor="sec-candidate_proc_full" title="Procedures for Full Implementation">


<section anchor="sec-role" title="Determining Role">

<t>
For each session, each ICE agent (Initiating and Responding) takes on
a role. There are two roles -- controlling and controlled. The
controlling agent is responsible for the choice of the final
candidate pairs used for communications. The sections below
describe in detail the actual procedures followed by controlling and
controlled agents.
</t>

<t>
The rules for determining the role and the impact on behavior are as
follows:
</t>

<t><list style="hanging">
<t hangText="Both agents are full:"> The initiating agent that
started the ICE processing MUST take the controlling role, and the
other MUST take the controlled role. Both agents will form check
lists, run the ICE state machines, and generate connectivity
checks. The controlling agent will execute the logic in <xref
target="sec-conclude-full"/> to nominate pairs that will become
(if the connectivity checks associated with the nominations succeed) 
the selected pairs, and then both agents end ICE as described in 
<xref target="sec-conc-state"/>.

</t>

<t hangText="One agent full, one lite:"> The full agent MUST take the
controlling role, and the lite agent MUST take the controlled
role. The full agent will form check lists, run the ICE state
machines, and generate connectivity checks. That agent will execute
the logic in <xref target="sec-conclude-full"/> to nominate pairs that
will become (if the connectivity checks associated with the nominations succeed) 
the selected pairs, and use the logic in <xref target="sec-conc-state"/> to 
end ICE. The lite implementation will just listen for connectivity checks, 
receive them and respond to them, and then conclude ICE as described in <xref
target="sec-lite-conclude"/>. For the lite implementation, the state
of ICE processing for each data stream is considered to be Running,
and the state of ICE overall is Running.
</t>

<t hangText="Both lite:"> The initiating agent that started the ICE
processing MUST take the controlling role, and the other MUST take the
controlled role. In this case, no connectivity checks are ever
sent. Rather, once the candidates are exchanged, each agent performs
the processing described in <xref target="sec-conclude"/> without
connectivity checks. It is possible that both agents will believe they
are controlled or controlling. In the latter case, the conflict is
resolved through glare detection capabilities in the signaling
protocol enabling the candidate exchange. The state of ICE processing
for each data stream is considered to be Running, and the state of
ICE overall is Running.
</t>
</list>
</t>

<t>
Once the roles are determined for a session, they persist throughout
the lifetime of the session. The roles can be re-determined as part
of an ICE restart (<xref target="sec-restart"/>), but an ICE agent
MUST NOT re-determine the role as part of an ICE restart unless one
or more of the following criteria is fulfilled:
</t>

<t><list style="hanging">
<t hangText="Full becomes lite:">
If the controlling agent is full, and switches to lite, the roles MUST be
re-determined if the peer agent is also full.
</t>

<t hangText="Role conflict:">
If the ICE restart causes a role conflict, the roles might be
re-determined due to the role conflict procedures in <xref target="sec-role-conflict"/>.
</t>

</list>
</t>

<t>
NOTE: There are certain 3PCC (third party call control)  <xref target="RFC3725"/> scenarios 
where an ICE restart might cause a role conflict.
</t>

<t>
NOTE: The agents needs to inform each other whether they are full
or lite before the roles are determined. The mechanism for that is
signalling protocol specific, and outside the scope of the document.
</t>

<t>
An agent MUST accept if the peer initiates a re-determination of the roles
even if the criteria for doing so are not fulfilled. This can happen if the
peer is compliant with RFC 5245.
</t>

</section>


<section anchor="sec-forming" title="Forming the Check Lists">

<t>
There is one check list for each data stream. To form a check list,
initiating and responding ICE agents form candidate pairs, compute
pair priorities, order pairs by priority, prune pairs, remove
lower-priority pairs, and set check list states. If candidates are
added to a check list (e.g., due to detection of peer reflexive
candidates), the agent will re-perform these steps for the updated
check list.
</t>
<section title="Check List State">
<t>Each check list has a state, which captures the state of ICE checks
for the data stream associated with the check list. The states
are:</t>
<t><list style="hanging">

<t hangText="Running:">The check list is neither Completed nor
Failed yet. Check lists are initially set to the Running state.
</t>

<t hangText="Completed:">The check list contains a nominated pair
for each component of the data stream.
</t>

<t hangText="Failed:">The check list does not have a valid pair
for each component of the data stream and all of the candidate
pairs in the check list are in either the Failed or Succeeded state.
In other words, at least one component of the check list has candidate
pairs that are all in the Failed state, which means the component has 
failed, which means the check list has failed.
</t>

</list></t>
</section>

<section title="Forming Candidate Pairs">

<t>
The ICE agent pairs each local candidate with each remote candidate for
the same component of the same data stream with the same IP address
family.  It is possible that some of the local candidates won't get
paired with remote candidates, and some of the remote candidates won't
get paired with local candidates. This can happen if one agent doesn't
include candidates for the all of the components for a data
stream. If this happens, the number of components for that data
stream is effectively reduced, and considered to be equal to the
minimum across both agents of the maximum component ID provided by
each agent across all components for the data stream.
</t>


<t>In the case of RTP, this would happen when one agent provides
candidates for RTCP, and the other does not. As another example, the
initiating agent can multiplex RTP and RTCP on the same port <xref
target="RFC5761"/>. However, since the initiating agent doesn't know
if the peer agent can perform such multiplexing, it includes
candidates for RTP and RTCP on separate ports. If the peer agent can
perform such multiplexing, it would include just a single component
for each candidate -- for the combined RTP/RTCP mux. ICE would end up
acting as if there was just a single component for this candidate.
</t>

<t>With IPv6 it is common for a host to have multiple host candidates
for each interface. To keep the amount of resulting candidate pairs
reasonable and to avoid candidate pairs that are highly unlikely to
work, IPv6 link-local addresses MUST NOT be paired with other than 
link-local addresses.
</t>

<t>
The candidate pairs whose local and remote candidates are both the
default candidates for a particular component is called the
default candidate pair for that component. This is the pair that
would be used to transmit data if both agents had not
been ICE aware.
</t>

<t>
<xref target="fig-check-model"/> shows the properties of and
relationships between transport addresses, candidates, candidate
pairs, and check lists.
</t>

<figure title="Conceptual Diagram of a Check List"
	anchor="fig-check-model" align="center"><artwork>
<![CDATA[
    +--------------------------------------------+
    |                                            |
    | +---------------------+                    |
    | |+----+ +----+ +----+ |   +Type            |
    | || IP | |Port| |Tran| |   +Priority        |
    | ||Addr| |    | |    | |   +Foundation      |
    | |+----+ +----+ +----+ |   +Component ID    |
    | |      Transport      |   +Related Address |
    | |        Addr         |                    |
    | +---------------------+   +Base            |
    |             Candidate                      |
    +--------------------------------------------+
    *                                         *
    *    *************************************
    *    *
  +-------------------------------+
 .|                               |
  | Local     Remote              |
  | +----+    +----+   +default?  |
  | |Cand|    |Cand|   +valid?    |
  | +----+    +----+   +nominated?|
  |                    +State     |
  |                               |
  |                               |
  |          Candidate Pair       |
  +-------------------------------+
  *                              *
  *                  ************
  *                  *
  +------------------+
  |  Candidate Pair  |
  +------------------+
  +------------------+
  |  Candidate Pair  |
  +------------------+
  +------------------+
  |  Candidate Pair  |
  +------------------+


         Check
         List

]]></artwork></figure>


</section>

<section anchor="sec-comp-pair-prio" title="Computing Pair Priority and Ordering Pairs">

<t>
The ICE agent computes a priority for each candidate pair. Let G be the
priority for the candidate provided by the controlling agent. Let D be
the priority for the candidate provided by the controlled agent.
The priority for a pair is computed as follows:
</t>

<t><list style="empty">
<t>
pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)
</t>
</list></t>

<t>
The agent sorts each check list in decreasing order of candidate pair
priority. If two pairs have identical priority, the ordering amongst
them is arbitrary.
</t>

</section>

<section title="Pruning the Pairs">

<t>
This sorted list of candidate pairs is used to determine a sequence of
connectivity checks that will be performed. Each check involves
sending a request from a local candidate to a remote candidate. Since
an ICE agent cannot send requests directly from a reflexive candidate
(server reflexive or peer reflexive), but only from its base, the
agent next goes through the sorted list of candidate pairs. For each
pair where the local candidate is reflexive, the candidate MUST be
replaced by its base.
</t>

<t>
The agent prunes each check list.  This is done by removing a
candidate pair if it is redundant with a higher priority candidate
pair in the same check list.  Two candidate pairs are redundant if
their local candidates have the same base and their remote candidates
are identical.   The result is a sequence of ordered candidate
pairs, called the check list for that data stream.
</t>

</section>

<section title="Removing lower-priority Pairs">

<t>
In order to limit the attacks described in <xref target="sec-ice-hammer"/>, an ICE agent 
MUST limit the total number of connectivity checks the agent performs across all 
check lists in the check list set. This is done by limiting the total number of candidate pairs
in the check list set. The default limit of candidate pairs for the check list set is 100, 
but the value MUST be configurable. The limit is enforced by, within in each check list, 
discarding lower-priority candidate pairs until the total number of candidate pairs in the 
check list set is smaller than the limit value. The discarding SHOULD be done evenly so 
that the number of candidate pairs in each check list is reduced the same amount.
</t>
<t>
It is RECOMMENDED that a lower limit value than the default is picked when possible, 
and that the value is set to the maximum number of plausible candidate pairs that 
might be created in an actual deployment configuration. The requirement for configuration 
is meant to provide a tool for fixing this value in the field if, once deployed, it is 
found to be problematic.
</t>

</section>

<section title="Computing Candidate Pair States">

<t>
Each candidate pair in the check list has a foundation 
(the combination of the foundations of the local and
remote candidates in the pair) and one of the following states:
</t>

<t><list style="hanging">
<t hangText="Waiting:"> A check has not been sent for this pair, but
the pair is not Frozen.
</t>

<t hangText="In-Progress:"> A check has been sent for this pair, but
the transaction is in progress.
</t>

<t hangText="Succeeded:"> A check has been sent for this pair, and
produced a successful result.
</t>

<t hangText="Failed:"> A check has been sent for this pair, and
failed (a response to the check was never received, or a failure
response was received).
</t>

<t hangText="Frozen:"> A check for this pair has not been sent,
and it can not be sent until the pair is unfrozen and moved into the
Waiting state.
</t>
</list></t>

<t>
Pairs move between states as shown in <xref target="fig-state-fsm"/>.
</t>

<figure title="Pair State FSM" anchor="fig-state-fsm" align="center"><artwork>
<![CDATA[
   +-----------+
   |           |
   |           |
   |  Frozen   |
   |           |
   |           |
   +-----------+
         |
         |unfreeze
         |
         V
   +-----------+         +-----------+
   |           |         |           |
   |           | perform |           |
   |  Waiting  |-------->|In-Progress|
   |           |         |           |
   |           |         |           |
   +-----------+         +-----------+
                               / |
                             //  |
                           //    |
                         //      |
                        /        |
                      //         |
            failure //           |success
                  //             |
                 /               |
               //                |
             //                  |
           //                    |
          V                      V
   +-----------+         +-----------+
   |           |         |           |
   |           |         |           |
   |   Failed  |         | Succeeded |
   |           |         |           |
   |           |         |           |
   +-----------+         +-----------+
]]></artwork></figure>

<t><list style="numbers">

<t>
The initial states for each pair in a check list are computed by
performing the following sequence of steps:
</t>

<t>The check lists are placed in an ordered list (the order is determined
by each ICE usage), called the check list set.
</t>

<t>
The ICE agent initially places all candidate pairs in the Frozen state.
</t>

<t>The agent sets all of the check lists in the check list set to the Running
state.
</t>

<t>
For each foundation, the agent sets the state of exactly one candidate
pair to the Waiting state (unfreezing it).  The candidate pair to
unfreeze is chosen by finding the first candidate pair (ordered by
lowest component ID and then highest priority if component IDs are
equal) in the first check list (according to the usage-defined check 
list set order) that has that foundation.
</t>

</list></t>

<t>NOTE: The procedures above are different from RFC 5245, where only
candidate pairs in the first check list of were initially placed in
the Waiting state.  Now it applies to candidate pairs in the the first
check list which have that foundation, even if the first check list to
have that foundation is not the first check list in the check list set.
</t>

<t>
The table below illustrates an example.
</t>

<figure anchor="fig-state-initial" align="center"><artwork>
<![CDATA[

Table legend:

Each row (m1, m2,...) represents a check list associated with a data
stream. m1 represents the first check list in the check list set.

Each column (f1, f2,...) represents a foundation. Every candidate pair
within a given column share the same foundation.

f-cp represents a candidate pair in the Frozen state.

w-cp represents a candidate pair in the Waiting state.

1. The agent sets all of the pairs in the check list set to the Frozen
state.

      f1    f2    f3    f4    f5
    -----------------------------
m1 | f-cp  f-cp  f-cp
   |
m2 | f-cp  f-cp  f-cp  f-cp
   |
m3 | f-cp                    f-cp


2. For each foundation, the candidate pair with the lowest component ID
is placed in the Waiting state, unless a candidate pair associated with
the same foundation has already been put in the Waiting state in one of
the other examined check lists in the check list set.

      f1    f2    f3    f4    f5
    -----------------------------
m1 | w-cp  w-cp  w-cp
   |
m2 | f-cp  f-cp  f-cp  w-cp
   |
m3 | f-cp                    w-cp


In the first check list (m1) the candidate pair for each foundation is
placed in the Waiting state, as no pairs for the same foundations have
yet been placed in the Waiting state.

In the second check list (m2) the candidate pair for foundation f4 is
placed in the Waiting state. The candidate pair for foundations f1, f2
and f3 are kept in the Frozen state, as candidate pairs for those
foundations have already been placed in the Waiting state (within check
list m1).

In the third check list (m3) the candidate pair for foundation f5 is
placed in the Waiting state. The candidate pair for foundation f1 is
kept in the Frozen state, as a candidate pair for that foundation have
already been placed in the Waiting state (within check list m1).

Once each check list have been processed, one candidate pair for each
foundation in the check list set has been placed in the Waiting state.

]]></artwork></figure>

</section>
</section>

<section anchor="sec-state" title="ICE State">
<t>
The ICE agent has a state determined by the state of the check
lists. The state is Completed if all check lists are Completed, Failed
if all check lists are Failed, and Running otherwise.
</t>
</section>

<section anchor="sec-periodic" title="Scheduling Checks">
<section anchor="sec-periodic-queue" title="Triggered Check Queue">
<t>
Once the ICE agent has computed the check lists and created the check list set,
as described in <xref target="sec-forming"/>, the agent will begin performing
connectivity checks (ordinary and triggered). For triggered connectivity checks,
the agent maintains a FIFO queue for each check list, referred to as the 
triggered check queue, which contains candidate pairs for which checks are to 
be sent at the next available opportunity. The triggered check queue is initially empty.
</t>
</section>

<section anchor="sec-periodic-perform" title="Performing Connectivity Checks">
<t>The generation of ordinary and triggered connectivity checks is governed
by timer Ta. As soon as the initial states for the candidate pairs in the
check list set have been set, a check is performed for a candidate pair
within the first check list in the Running state, following
the procedures in <xref target="sec-connectivity_check"/>. After that,
whenever Ta fires the next check list in the Running state in the check list set
is picked, and a check is performed for a candidate within that check list.
After the last check list in the Running state in the check list set has been
processed, the first check list is picked again, etc.
</t>

<t>
Whenever Ta fires, the ICE agent will perform a check for a candidate pair within
the picked check list by performing the following steps:
<list style="numbers">
<t>If the triggered check queue associated with the check list contains
one or more candidate pairs, the agent removes the top pair from the
queue, performs a connectivity check on that pair, puts the candidate pair
state to In-Progress, and aborts the subsequent steps.
</t>

<t>If there is no candidate pair in the Waiting state, and if there are one or
more pairs in the Frozen state, for each pair in the Frozen state the agent
checks the foundation associated with the pair. For a given foundation, if there
is no pair (in any check list in the check list set) in the Waiting or In-Progress state,
the agent puts the candidate pair state to Waiting and continues with the next step.
</t>

<t>If there are one or more candidate pairs in the Waiting state, the agent picks
the highest-priority candidate pair (if there are multiple pairs with the same
priority, the pair with the lowest component ID is picked) in the Waiting
state, performs a connectivity check on that pair, puts the candidate pair
par state to In-Progress, and abort the subsequent steps.
</t>

<t>If this step is reached, no check could be performed for the picked check list.
So, without waiting for timer Ta to expire again, select the next check list
in the Running state and return to step #1. If this happens for every single
check list in the Running state, meaning there are no remaining candidate pairs
to perform connectivity checks for, abort these steps.
</t>

</list></t>

<t>Once the agent has picked a candidate pair for which a connectivity check is to
be performed, the agent starts a check and sends the Binding request from the base 
associated with the local candidate of the pair to the remote candidate of the pair, 
as described in <xref target="sec-send-check"/>.
</t>


<t>Based on local policy, an agent MAY choose to terminate performing the
connectivity checks for one or more checks lists in the check list set
at any time. However, only the controlling agent is allowed to
conclude ICE (<xref target="sec-conclude"/>).
</t>

<t>To compute the message integrity for the check, the agent uses the
remote username fragment and password learned from the candidate
information obtained from its peer. The local username fragment is
known directly by the agent for its own candidate.
</t>

</section>
</section>
<!-- end of full implementation -->
</section>

<section anchor="sec-candidate_proc_lite" title="Lite Implementation Procedures">

 <t>
 Lite implementations skip most of the steps in <xref
 target="sec-candidate_proc"/> except for verifying the peer's ICE
 support and determining its role in the ICE processing.
 </t>

 <t>
 If the lite implementation is the controlling agent (which will
 only happen if the peer ICE agent is also a lite implementation), it
 selects a candidate pair based on the ones in the candidate exchange 
 (for IPv4, there is only ever one pair), and then updating the peer 
 with the new candidate information reflecting that selection, if 
 needed (it is never needed for an IPv4-only host).
 </t>

</section>

</section>


<section anchor="sec-connectivity_check" title="Performing Connectivity Checks">

<t>This section describes how connectivity checks are performed.
</t>
<t>An ICE agent MUST be compliant to <xref target="RFC5389"/>. A full
implementation acts both as a STUN client and a STUN server, while a
lite implementation only acts as a STUN server (as it does not generate
connectivity checks).
</t>

<section title="STUN Extensions">
<t>ICE extends STUN by defining new attributes: PRIORITY, USE-CANDIDATE,
ICE-CONTROLLED, and ICE-CONTROLLING. The new attributes are formally defined in
<xref target="sec-ice-newatts"/>. This section describes the usage of the
new attributes.
</t>
<t>The new attributes are only applicable to ICE connectivity checks.
</t>

<section title="PRIORITY">
<t>The priority attribute MUST be included in a Binding request and be
set to the value computed by the algorithm in <xref
target="sec-prioritizing"/> for the local candidate, but with the
candidate type preference of peer reflexive candidates.
</t>
</section>

<section title="USE-CANDIDATE">
<t>The controlling agent MUST include the USE-CANDIDATE attribute in
order to nominate a candidate pair (<xref target="sec-choose-favor"/>).
The controlled agent MUST NOT include the USE-CANDIDATE attribute
in a Binding request.
</t>
</section>

<section anchor="sec-tie-client" title="ICE-CONTROLLED and ICE-CONTROLLING">
<t>The controlling agent MUST include the ICE-CONTROLLING attribute in a Binding
request. The controlled agent MUST include the ICE-CONTROLLED attribute in
a Binding request.
</t>
<t>The content of either attribute are used as tie-breaker values
when an ICE role conflict occurs (<xref target="sec-role-conflict"/>).
</t>
</section>
</section>


<section anchor="sec-client" title="STUN Client Procedures">
<section anchor="sec-permissions" title="Creating Permissions for Relayed Candidates">
<t>If the connectivity check is being sent using a relayed local
candidate, the client MUST create a permission first if it has not
already created one previously. It would have created one previously
if it had told the TURN server to create a permission for the given
relayed candidate towards the IP address of the remote candidate.  To
create the permission, the ICE agent follows the procedures defined in
<xref target="RFC5766"/>.  The permission MUST be created towards the
IP address of the remote candidate.  It is RECOMMENDED that the agent
defer creation of a TURN channel until ICE completes, in which case
permissions for connectivity checks are normally created using a
CreatePermission request.  Once established, the agent MUST keep the
permission active until ICE concludes.
</t>
</section>

<section title="Forming Credentials">
<t>A connectivity check Binding request MUST utilize the STUN
short-term credential mechanism.
</t>
<t>The username for the credential is formed by concatenating the
username fragment provided by the peer with the username fragment
of the ICE agent sending the request, separated by a colon (":").
</t>
<t>The password is equal to the password provided by
the peer.
</t>
<t>For example, consider the case where ICE agent L is the
Initiating agent and ICE agent R is the Responding agent. Agent L
included a username fragment of LFRAG for its candidates and a
password of LPASS. Agent R provided a username fragment of RFRAG and a
password of RPASS. A connectivity check from L to R utilizes the
username RFRAG:LFRAG and a password of RPASS. A connectivity check
from R to L utilizes the username LFRAG:RFRAG and a password of
LPASS. The responses utilize the same usernames and passwords as the
requests (note that the USERNAME attribute is not present in the
response).
</t>
</section>

<section title="DiffServ Treatment">
<t>
If the agent is using Diffserv Codepoint markings <xref target="RFC2475"/> 
in data packets that it will send, the agent SHOULD apply the same markings to
Binding requests and responses that it will send.
</t>
<t>If multiple DSCP markings are used on the data packets, the
agent SHOULD choose one of them for use with the connectivity check.
</t>
</section>

<section anchor="sec-send-check" title="Sending the Request">
<t>A connectivity check is generated by sending a Binding request from
the base associated with a local candidate to a remote candidate.
<xref target="RFC5389"/> describes how Binding requests are constructed
and generated.
</t>
<t>Support for backwards compatibility with RFC 3489 MUST NOT
be assumed when performing connectivity checks. The FINGERPRINT mechanism
MUST be used for connectivity checks.
</t>
</section>

<section anchor="sec-recv-response" title="Processing the Response">
<t>This section defines additional procedures for processing Binding responses
specific to ICE connectivity checks.
</t>
<t>When a Binding response is received, it is correlated to the corresponding
Binding request using the transaction ID <xref target="RFC5389"/>, which then
associates the response with the candidate pair for which the Binding request
was sent. After that, the response is processed according to the procedures for
a role conflict, a failure, or a success, according to the procedures below.
</t>
<section anchor="sec-recv-response-conf" title="Role Conflict">
    <t>If the Binding request generates a 487 (Role Conflict) error
    response (<xref target="sec-role-conflict"/>), and if the ICE agent 
    included an ICE-CONTROLLED attribute
    in the request, the agent MUST switch to the controlling role. If
    the agent included an ICE-CONTROLLING attribute in the request,
    the agent MUST switch to the controlled role.
    </t>
    <t>Once the agent has switched its role, the agent MUST add the
    candidate pair whose check generated the 487 error response to the
    triggered check queue associated with the check list to which the
    pair belongs, and set the candidate pair state to Waiting. When the
    triggered connectivity check is later performed, the
    ICE-CONTROLLING/ICE-CONTROLLED attribute of the Binding request will
    indicate the agent's new role. The agent MAY change
    the tie-breaker value.
    </t>
    <t>NOTE: A role switch requires an agent to recompute pair priorities
    (<xref target="sec-comp-pair-prio"/>), since the priority values
    depend on the role.
    </t>
    <t>NOTE: A role switch will also impact whether the agent is responsible
    for nominating candidate pairs, and whether the agent is responsible
    for initiating the exchange of the updated candidate information with
    the peer once ICE is concluded.
    </t>
</section>

<section anchor="sec-client-failure" title="Failure">
    <t>This section describes cases when the candidate pair state is set to Failed.
    </t>
    <t>NOTE: When the ICE agent sets the candidate pair state to Failed as a
    result of a connectivity check error, the agent does not change the states
    of other candidate pairs with the same foundation.
    </t>
    <section title="Non-Symmetric Transport Addresses">
    <t>The ICE agent MUST check that the source and destination transport addresses
    in the Binding request and response are symmetric. I.e., the source IP address
    and port of the response MUST be equal to the destination IP address and port to which the
    Binding request was sent, and that the destination IP address and port of the response
    MUST be equal to the source IP address and port from which the Binding request was sent.
    If the addresses are not symmetric, the agent MUST set the candidate pair state
    to Failed.
    </t>
    </section>
    <section title="ICMP Error">
    <t>
    An ICE agent MAY support processing of ICMP errors for connectivity
    checks. If the agent supports processing of ICMP errors, and if a
    Binding request generates a hard ICMP error, the agent SHOULD set the
    state of the candidate pair to Failed. Implementers need to be aware
    that ICMP errors can be used as a method for denial of service attacks
    when making a decision on how and if to process ICMP errors.
    </t>
    </section>
    <section title="Timeout">
    <t>If the Binding request transaction times out, the ICE agent MUST set
    the candidate pair state to Failed.
    </t>
    </section>
    <section title="Unrecoverable STUN Response">
    <t>If the Binding request generates a STUN error response that is
    unrecoverable <xref target="RFC5389"/> the ICE agent SHOULD set
    the candidate pair state to Failed.
    </t>
    </section>
</section>

<section title="Success">

<t>A connectivity check is considered a success if each of the following criteria
is true:
<list style="symbols">
<t>The Binding request generated a success response; and</t>
<t>The source and destination transport addresses in the Binding
request and response are symmetric.</t>
</list></t>
<t> If a check is considered a success, the ICE agent performs (in order) the 
actions described in the following sections.
</t>

<section anchor="sec-learn-peer-client" title="Discovering Peer Reflexive Candidates">

<t>The ICE agent MUST check the mapped address from the STUN response. If the
transport address does not match any of the local candidates that the
agent knows about, the mapped address represents a new candidate: a
peer reflexive candidate. Like other candidates, a peer reflexive candidate
has a type, base, priority, and foundation. They are computed as follows:
</t>

<t><list style="symbols">
<t>The type is peer reflexive.</t>
<t>The base is the local candidate of the candidate pair
from which the Binding request was sent.</t>
<t>The priority is the value of the PRIORITY attribute in
the Binding request.</t>
<t>The foundation is described in <xref target="sec-computing-foundations"/>.</t>
</list></t>
<t>The peer reflexive candidate is then added to the list of local
candidates for the data stream. The username fragment and password
are the same as for all other local candidates for that data stream.
</t>
<t>The ICE agent does not need to pair the peer reflexive
candidate with remote candidates, as a valid pair will be
created due to the procedures in <xref target="sec-valid-cons"/>.
If an agent wishes to pair the peer reflexive candidate with
remote candidates other than the one in the valid pair that will
be generated, the agent MAY provide updated candidate information to
the peer that includes the peer reflexive candidate. This will cause
the peer reflexive candidate to be paired with all other remote candidates.
</t>
</section>

<section anchor="sec-valid-cons" title="Constructing a Valid Pair">
<t>The ICE agent constructs a candidate pair whose local candidate equals the
mapped address of the response, and whose remote candidate equals the
destination address to which the request was sent. This is called a
valid pair.
</t>
<t>The valid pair might equal the pair that generated the connectivity check,
a different pair in the check list, or a pair currently not in the check list.
</t>
<t>The agent maintains a separate list, referred to as the valid list. There is
a valid list for each check list in the check list set. The valid list will contain 
valid pairs. Initially each valid list is empty.
</t>
<t>Each valid pair within the valid list has a flag, called the nominated flag.
When a valid pair is added to a valid list, the flag value is set to 'false'.
</t>
<t>The valid pair will be added to a valid list as follows:
<list style="numbers">
<t>If the valid pair equals the pair that generated the check, the pair is added to
the valid list associated with the check list to which the pair belongs; or
</t>
<t>If the valid pair equals another pair in a check list, that pair is added
to the valid list associated with the check list of that pair. The pair that
generated the check is not added to a valid list; or
</t>
<t>If the valid pair is not in any check list, the agent computes the priority
for the pair based on the priority of each candidate, using the
algorithm in <xref target="sec-forming"/>. The priority of the local
candidate depends on its type. Unless the type is peer reflexive, the
priority is equal to the priority signaled for that candidate in the candidate
exchange. If the type is peer reflexive, it is equal to the PRIORITY
attribute the agent placed in the Binding request that just
completed. The priority of the remote candidate is taken from the
candidate information of the peer. If the candidate does not appear
there, then the check has been a triggered check to a new remote
candidate. In that case, the priority is taken as the value of the
PRIORITY attribute in the Binding request that triggered the check
that just completed. The pair is then added to the valid list.
</t>
</list></t>
<t>NOTE: It will be very common that the valid pair will not be in any check list.
Recall that the check list has pairs whose local candidates are never
reflexive; those pairs had their local candidates converted to
the base of the reflexive candidates, and then pruned if they
were redundant. When the response to the Binding request arrives, the
mapped address will be reflexive if there is a NAT between the two. In
that case, the valid pair will have a local candidate that doesn't
match any of the pairs in the check list.
</t>
</section>


<section title="Updating Candidate Pair States">
<t>The ICE agent sets the states of both the candidate pair that generated
the check and the constructed valid pair (which may be different) to
Succeeded.
</t>
<t>The agent MUST set the states for all other Frozen candidate pairs
in all check lists with the same foundation to Waiting.
</t>
<t>NOTE: Within a given check list, candidate pairs with the same foundations will
typically have different component ID values.
</t>
</section>

<section title="Updating the Nominated Flag">
<t>If the controlling agent sends a Binding request with the USE-CANDIDATE
attribute set, and if the ICE agent receives a successful response to the request, 
the agent sets the nominated flag of the pair to true. If the request fails
(<xref target="sec-client-failure"/>), the agent MUST remove the candidate pair 
from the valid list, set the candidate pair state to Failed and set the check list 
state to Failed.
</t>
<t>If the controlled agent receives a successful response to a Binding request
sent by the agent, and that Binding request was triggered by a received Binding
request with the USE-CANDIDATE attribute set (<xref target="sec-triggered"/>), the
agent sets the nominated flag of the pair to true. If the triggered request
fails, the agent MUST remove the candidate pair from the valid list, set the 
candidate pair state to Failed and set the check list state to Failed.
</t>
<t>Once the nominated flag is set for a component of a data stream, it concludes
the ICE processing for that component (<xref target="sec-conclude"/>).
</t>
</section>


<!-- end success cases -->
</section>

<section title="Check List State Updates">
<t>
Regardless of whether a connectivity check was successful or failed, the
completion of the check may require updating of check list states.
For each check list in the check list set, if all of the candidate pairs
are in either Failed or Succeeded state, and if there is not a valid pair in
the valid list for each component of the data stream associated with the
check list, the state of the check list is set to Failed. If there is a
valid pair for each component in the valid list, the state of the check
list is set to Succeeded.
</t>
</section>
</section>
<!-- end processing response -->
</section>


<section anchor="sec-serverproc" title="STUN Server Procedures">

<t>
An ICE agent (lite or full) MUST be prepared to receive Binding requests
on the base of each candidate it included in its most recent candidate
exchange.
</t>

<t>
The agent MUST use the short-term credential mechanism (i.e., the
MESSAGE-INTEGRITY attribute) to authenticate the request and perform a
message integrity check. Likewise, the short-term credential mechanism
MUST be used for the response. The agent MUST consider the username to
be valid if it consists of two values separated by a colon, where the
first value is equal to the username fragment generated by the agent
in a candidate exchange for a session in-progress. It is possible
(and in fact very likely) that the initiating agent will receive a
Binding request prior to receiving the candidates from its peer. If
this happens, the agent MUST immediately generate a response
(including computation of the mapped address as described in <xref
target="sec-compute-mapped"/>). The agent has sufficient information
at this point to generate the response; the password from the peer is
not required. Once the answer is received, it MUST proceed with the
remaining steps required, namely, <xref
target="sec-learn-peer-server"/>, <xref target="sec-triggered"/>, and
<xref target="sec-up-fav"/> for full implementations. In cases where
multiple STUN requests are received before the answer, this may cause
several pairs to be queued up in the triggered check queue.
</t>

<t>
An agent MUST NOT utilize the ALTERNATE-SERVER mechanism, and MUST NOT
support the backwards-compatibility mechanisms to RFC 3489. It MUST
utilize the FINGERPRINT mechanism.
</t>

<t>
If the agent is using Diffserv Codepoint markings <xref
target="RFC2475"/> in its data packets, it SHOULD apply the same
markings to Binding responses. The same would apply to any layer 2
markings the endpoint might be applying to data packets.
</t>

<section anchor="sec-add-server-full" title="Additional Procedures for Full Implementations">

<t>This subsection defines the additional server procedures applicable
to full implementations, when the full implementation accepts the Binding 
request.
</t>

<section anchor="sec-role-conflict" title="Detecting and Repairing Role Conflicts">
<t>
In certain usages of ICE (such as 3PCC), both
ICE agents may end up choosing the same role, resulting in a role
conflict.  The section describes a mechanism for detecting and
repairing role conflicts.  The usage document MUST specify whether
this mechanism is needed.
</t>

<t>
An agent MUST examine the Binding request for either the
ICE-CONTROLLING or ICE-CONTROLLED attribute. It MUST follow these
procedures:
<list style="symbols">

<t>
If the agent is in the controlling role, and the ICE-CONTROLLING
attribute is present in the request:
<list style="symbols">
<t>
If the agent's tie-breaker value is larger than or equal to the contents
of the ICE-CONTROLLING attribute, the agent generates a Binding error
response and includes an ERROR-CODE attribute with a value of 487
(Role Conflict) but retains its role.
</t>
<t>
If the agent's tie-breaker value is less than the contents of the
ICE-CONTROLLING attribute, the agent switches to the controlled
role.
</t>
</list>
</t>

<t>
If the agent is in the controlled role, and the ICE-CONTROLLED
attribute is present in the request:
<list style="symbols">
<t>
If the agent's tie-breaker value is larger than or equal to the contents
of the ICE-CONTROLLED attribute, the agent switches to the
controlling role.
</t>
<t>
If the agent's tie-breaker value is less than the contents of the
ICE-CONTROLLED attribute, the agent generates a Binding error response
and includes an ERROR-CODE attribute with a value of 487 (Role
Conflict) but retains its role.
</t>
</list>
</t>

<t>
If the agent is in the controlled role and the ICE-CONTROLLING
attribute was present in the request, or the agent was in the
controlling role and the ICE-CONTROLLED attribute was present in the
request, there is no conflict.
</t>

</list></t>

<t>
A change in roles will require an agent to recompute pair priorities
(<xref target="sec-comp-pair-prio"/>), since those priorities are a
function of role. The change in role will also impact whether the
agent is responsible for selecting nominated pairs and initiating
exchange with updated candidate information upon conclusion of ICE.
</t>

<t>
The remaining sections in <xref target="sec-add-server-full"/> are
followed if the agent generated a successful response to the Binding
request, even if the agent changed roles.
</t>

</section>


<section anchor="sec-compute-mapped" title="Computing Mapped Address">

<t>
For requests received on a relayed candidate, the source
transport address used for STUN processing (namely, generation of the
XOR-MAPPED-ADDRESS attribute) is the transport address as seen by the
TURN server. That source transport address will be present in the
XOR-PEER-ADDRESS attribute of a Data Indication message, if the
Binding request was delivered through a Data Indication. If the
Binding request was delivered through a ChannelData message, the
source transport address is the one that was bound to the channel.
</t>

</section>

<section anchor="sec-learn-peer-server" title="Learning Peer Reflexive Candidates">

<t>
If the source transport address of the request does not match any
existing remote candidates, it represents a new peer reflexive remote
candidate. This candidate is constructed as follows:
<list style="symbols">
<t>The type is peer reflexive.</t>
<t>The priority is the value of the PRIORITY attribute in
the Binding request.</t>
<t>The foundation is an arbitrary value,
different from the foundations of all other remote candidates. If any
subsequent candidate exchanges contain this peer reflexive
candidate, it will signal the actual foundation for the
candidate.</t>
<t>The component ID is the component ID of
the local candidate to which the request was sent.
</t>
</list>
</t>

<t>This candidate is added to the list of remote candidates. However,
the ICE agent does not pair this candidate with any local candidates.
</t>

</section>

<section anchor="sec-triggered" title="Triggered Checks">

<t>
Next, the agent constructs a pair whose local candidate has
the transport address (as seen by the agent) on which the STUN request was received, and a
remote candidate equal to the source transport address where the
request came from (which may be the peer reflexive remote candidate
that was just learned). The local candidate will either be a host
candidate (for cases where the request was not received through a
relay) or a relayed candidate (for cases where it is received through
a relay).  The local candidate can never be a server reflexive
candidate. Since both candidates are known to the agent, it can obtain
their priorities and compute the candidate pair priority. This pair is
then looked up in the check list. There can be one of several
outcomes:

<list style="symbols">
  <t>If the pair is already on the check list:
    <list style="symbols">
      <t>If the state of that pair is In-Progress or Succeeded, nothing further is
      done. </t>
      <t>If the state of that pair is Waiting or Frozen, a check for that pair 
      is enqueued into the triggered check queue if not already present.
      </t>
      <t> If the state of the pair is Failed, it is changed to Waiting
      and the agent MUST create a new connectivity check for that pair
      (representing a new STUN Binding request transaction), by
      enqueueing the pair in the triggered check queue. Note that the
      change of the state pair might also trigger a change of the 
      check list state, if the current check list state is Failed.
      </t>

    </list>
  </t>
</list>
</t>

<t>
These steps are done to facilitate rapid completion of ICE when both
agents are behind NAT.

<list style="symbols">
  <t>If the pair is not already on the check list:
  <list style="symbols">
    <t>The pair is inserted into the check list based on its priority.</t>
    <t>Its state is set to Waiting.</t>
    <t>The pair is enqueued into the triggered check queue. </t>
  </list>
  </t>
</list>

</t>

<t>
When a triggered check is to be sent, it is constructed and processed
as described in <xref target="sec-send-check"/>. These procedures
require the agent to know the transport address, username fragment,
and password for the peer. The username fragment for the remote
candidate is equal to the part after the colon of the USERNAME in the
Binding request that was just received. Using that username fragment,
the agent can check the candidates received from its peer (there
may be more than one in cases of forking), and find this username
fragment. The corresponding password is then picked.
</t>

<!-- end triggered checks -->
</section>

<section anchor="sec-up-fav" title="Updating the Nominated Flag">

<t>If the controlled agent receives a Binding request with the USE-CANDIDATE
attribute set, and if the ICE agent accepts the request, the following action
is based on the state of the pair computed in <xref target="sec-triggered"/>:
<list style="symbols">
<t>If the state of this pair is Succeeded, it means that the check
previously sent by this pair produced a successful response, and
generated a valid pair (<xref target="sec-valid-cons"/>). The agent sets
the nominated flag value of the valid pair to true. 
</t>
<t>If the received Binding request triggered a new check to be enqued in the
triggered check queue (<xref target="sec-triggered"/>), once the check is
sent and if it generates a successful response, and generates a valid pair, the 
agent sets the nominated flag of the pair to true. If the request fails 
(<xref target="sec-client-failure"/>), the agent MUST remove the candidate pair 
from the valid list, set the candidate pair state to Failed and set the check list 
state to Failed.
</t>
</list>
</t>
<t>If the controlled agent does not accept the request from the 
controlling agent, the controlled agent MUST reject the nomination request with 
an appropriate error code response (e.g., 400) <xref target="RFC5389"/>.
</t>
<t>Once the nominated flag is set for a component of a data stream, it concludes
the ICE processing for that component. See <xref target="sec-conclude"/>.
</t>
</section>

<!-- end full implementation requirements -->
</section>

<section title="Additional Procedures for Lite Implementations">

<t>If the controlled agent receives a Binding request with the USE-CANDIDATE
attribute set, and if the ICE agent accepts the request, the agent 
constructs a candidate pair whose local candidate has the 
transport address on which the request was received, and whose remote 
candidate is equal to the source transport address of the request that 
was received. This candidate pair is assigned an arbitrary priority, and 
placed into the valid list of the associated check list. The agent 
sets the nominated flag for that pair to true. 
</t>
<t>Once the nominated flag is set for a component of a data stream, it concludes
the ICE processing for that component. See <xref target="sec-conclude"/>.
</t>
</section>


<!-- end server procedures -->
</section>


<!-- end connectivity checks -->
</section>

<section anchor="sec-conclude" title="Concluding ICE Processing">

<t>This section describes how an ICE agent completes ICE.
</t>

<section anchor="sec-conclude-full" title="Procedures for Full Implementations">

<t>
Concluding ICE involves nominating pairs by the controlling agent and
updating of state machinery.
</t>

<section anchor="sec-choose-favor" title="Nominating Pairs">

<t>Prior to nominating, the controlling agent let connectivity checks continue until
some stopping criterion is met. After that, based on an evaluation
criterion, the controlling agent picks a pair among the valid pairs in the valid list
for nomination.
</t>
<t>Once the controlling agent has picked a valid pair for nomination, it
repeats the connectivity check that produced this valid pair (by enqueueing
the pair that generated the check into the triggered check queue), this time with
the USE-CANDIDATE attribute <xref target="sec-up-fav"/>.
</t>
<t>Eventually, if the nominations succeed, both the controlling and controlled agents
will have a single nominated pair in the valid list for each component of the data stream. 
Once an ICE agent sets the state of the check list to Completed (when there is a nominated pair 
for each component of the data stream), that pair becomes the selected pair for that agent, and 
is used for sending and receiving data for that component of the data stream.
</t>
<t>If an agent is not able to produce selected pairs for a data stream, the agent MUST take proper
actions for informing the other agent, and e.g., removing the stream. The exact actions are outside
the scope of this specification.
</t>
<t>The criteria for stopping the connectivity checks and for
selecting a pair for nomination, are outside the scope of this specification.
They are a matter of local optimization. The only requirement is that the
agent MUST eventually pick one and only one candidate pair and generate a
check for that pair with the USE-CANDIDATE attribute set.
</t>
<t>If more than one candidate pair is nominated by the controlling agent, and if
the controlled agent accepts multiple nominations requests, the agents 
MUST produce the selected pairs using the pairs with the highest priority.</t>
<t>NOTE: A controlling agent that does not support this specification (i.e. it
is implemented according to RFC 5245) might nominate more than one candidate pair.
This was referred to as "aggressive nomination" in RFC 5245. The usage of the
'ice2' ice option (<xref target="sec-ice-option"/>) by endpoints supporting this 
specification is supposed to prevent such controlling agents from using aggressive nomination.
</t>
<t>NOTE: In RFC 5245, usage of "aggressive nomination" allowed agents to continuously nominate
pairs, before a pair was eventually selected, in order to allow sending of data on those pairs.
In this specification, data can always be sent on any valid pair, without nomination. Hence,
there is no longer a need for aggressive nomination.
</t>


</section>

<section anchor="sec-conc-state" title="Updating States">

<t>
For both controlling and controlled agents, the state of ICE
processing depends on the presence of nominated candidate pairs in the
valid list and on the state of the check list. Note that, at any time,
more than one of the following cases can apply:
</t>

<t><list style="symbols">

<t>If there are no nominated pairs in the valid list for a data
stream and the state of the check list is Running, ICE processing
continues.
</t>


<t>If there is at least one nominated pair in the valid list for a
data stream and the state of the check list is Running:
<list style="symbols">
<t>The ICE agent MUST remove all Waiting and Frozen pairs in the CHECK
LIST and triggered check queue for the same component as the nominated
pairs for that data stream.
</t>
<t>If an In-Progress pair in the check list is for the same component
as a nominated pair, the agent SHOULD cease retransmissions for its
check if its pair priority is lower than the lowest-priority nominated
pair for that component.
</t>
</list>
</t>

<t>Once there is at least one nominated pair in the valid list for
every component of at least one data stream and the state of the
check list is Running:
<list style="symbols">
<t>The agent MUST change the state of processing for its check list
for that data stream to Completed. </t>
<t>The agent MUST continue to respond to any checks it may still
receive for that data stream, and MUST perform triggered checks if
required by the processing of <xref target="sec-serverproc"/>.
</t>
<t>The agent MUST continue retransmitting any In-Progress checks for
that check list.</t>
</t>
</list>
</t>

<t>Once the state of each check list is Completed:
<list style="symbols">
<t>The agent sets the state of ICE processing overall to Completed.</t>
</list>
</t>

<t>If the state of the check list is Failed, ICE has not been
able to complete for this data stream. The correct behavior depends
on the state of the check lists for other data streams:
<list style="symbols">
<t>If all check lists are Failed, ICE processing overall is considered
to be in the Failed state, and the agent SHOULD consider the session a
failure, SHOULD NOT restart ICE, and the controlling agent SHOULD
terminate the entire session. </t>
<t>If at least one of the check lists for other data streams is
Completed, the controlling agent SHOULD remove the failed data stream
from the session while sending updated candidate list to its peer.</t>
<t> If none of the check lists for other data streams are
Completed, but at least one is Running, the agent SHOULD let ICE
continue.</t>
</list>
</t>

</list></t>

</section>

</section>

<section anchor="sec-lite-conclude" title="Procedures for Lite Implementations">

<t>
When ICE concludes, a lite ICE agent can free host candidates that were
not used by ICE, as described in <xref target="sec-freeing"/>.
</t>

<t>
If the peer is a full agent, once the lite agent accepts a nomination request
for a candidate pair, the lite agent considers the pair nominated. Once there
are nominated pairs for each component of a data stream, the pairs become
the selected pairs for the components of the data stream. Once the lite agent 
has produced selected pairs for all components of all data streams, the ICE session
state is set to Completed.
</t>

<t>
If the peer is a lite agent, the agent pairs local candidates with
remote candidates that are for the same data stream and have the same
component, transport protocol, and IP address family.  For each
component of each data stream, if there is only one candidate pair,
that pair is added to the valid list.  If there is more than one pair,
it is RECOMMENDED that an agent follow the procedures of RFC 6724
<xref target="RFC6724"/> to select a pair and add it to the valid
list.
</t>

<t>If all of the components for all data streams had one pair, the
state of ICE processing is Completed.  Otherwise, the controlling
agent MUST send an updated candidate list to reconcile different
agents selecting different candidate pairs. ICE processing is
complete after and only after the updated candidate exchange is
complete.
</t>

<!-- procedures for lite -->
</section>

<section anchor="sec-freeing" title="Freeing Candidates">

<section title="Full Implementation Procedures">

<t>
The rules in this section describe when it is safe
for an agent to cease sending or receiving checks on a candidate that
did not become a selected candidate (is not associated with a selected pair), 
and then free the candidate.
</t>	
	
<t>
Once a check list has reached the Completed state, the agent SHOULD wait an
additional three seconds, and then it can cease responding to checks or
generating triggered checks on all local candidates other than
the ones that became selected candidates.
Once all ICE sessions have ceased using a given local candidate 
(a candidate may be used by multiple ICE sessions, e.g., in forking scenarios), 
the agent can free that candidate.  The three-second delay
handles cases when aggressive nomination is used, and the selected pairs
can quickly change after ICE has completed.
</t>
	
<t>
Freeing of server reflexive candidates is never
explicit; it happens by lack of a keepalive.  
</t>

</section>

<section title="Lite Implementation Procedures">

<t>
A lite implementation can free candidates that did not become selected candidates 
as soon as ICE processing has reached the Completed state for all ICE sessions
using those candidates.
</t>

</section>

<!-- freeing -->
</section>

<!-- concluding -->
</section>


<section anchor="sec-restart" title="ICE Restarts">
<t>
An ICE agent MAY restart ICE for existing data streams. An ICE restart
causes all previous state of the data streams, excluding the roles of
the agents, to be flushed.  The only difference between an ICE restart
and a brand new data session is that during the restart, data can
continue to be sent using existing data sessions, and that a new data
session always requires the roles to be determined.
</t>

<t>
The following actions can be accomplished only using an ICE restart
(the agent MUST use ICE restarts to do so):
</t>

<t>
<list style="symbols">
<t>Change the destinations of data streams.</t>
<t>Change from a lite implementation to a full implementation.</t>
<t>Change from a full implementation to a lite implementation.</t>
</list>
</t>

<t>
To restart ICE, an agent MUST change both the password and the
username fragment for the data stream(s) being restarted.  
</t>
<t>
When the ICE is restarted, the candidate set for the new ICE session 
might include some, none, or all of the candidates used in the current ICE session.
</t>

<t>
As described in <xref target="sec-role"/>, agents MUST NOT
re-determine the roles as part as an ICE restart, unless certain
criteria that require the roles to be re-determined are fulfilled.
</t>

</section>



<section anchor="sec-ice-option" title="ICE Option">

<t>
This section defines a new ICE option, 'ice2'. The ICE option
indicates that the ICE agent that includes it in a candidate exchange
is compliant to this specification. For example, the agent will not 
use the aggressive nomination procedure defined in RFC 5245. In addition,
it will ensure that an RFC 5245-compliant peer does not use aggressive nomination 
either, as required by Section 14 of RFC 5245 for peers which receive unknown ICE options.

</t>
<t>
An agent compliant to this specification MUST inform the peer
about the compliance using the 'ice2' option.
</t>
<t>
NOTE: The encoding of the 'ice2' ICE option, and the message(s)
used to carry it to the peer, are protocol specific. The encoding
for the Session Description Protocol (SDP) <xref target="RFC4566"/>
is defined in <xref target="I-D.ietf-mmusic-ice-sip-sdp"/>.
</t>

</section>


<section anchor="sec-keepalives" title="Keepalives">

<t>
All endpoints MUST send keepalives for each data session. These
keepalives serve the purpose of keeping NAT bindings alive for the
data session. The keepalives SHOULD be sent using a
format that is supported by its peer. ICE endpoints allow for
STUN-based keepalives for UDP streams, and as such, STUN keepalives
MUST be used when an ICE agent is a full ICE implementation and is
communicating with a peer that supports ICE (lite or full).
</t>
<t>
For each candidate pair that an agent is using to send data, if no
packet has been sent on that pair in the last Tr seconds, an agent
MUST send a keepalive on that pair. Agents SHOULD use a Tr value of 
15 seconds. Agents MAY use a bigger value, but MUST NOT use a value 
smaller than 15 seconds.
</t>
<t>
Once selected pairs have been produced for a data stream, keepalives 
are only sent on those pairs.
</t>
<t>
An agent MUST stop sending keepalives on a data stream if the data stream is
removed. If the ICE session is terminated, an agent MUST stop sending
keepalives on all data streams.
</t>
<t>
An agent MAY use another value for Tr, e.g. based on
configuration or network/NAT characteristics. For example, if
an agent has a dynamic way to discover the binding lifetimes of the
intervening NATs, it can use that value to determine Tr. Administrators
deploying ICE in more controlled networking environments SHOULD set Tr
to the longest duration possible in their environment.
</t>
<t>
When STUN is being used for keepalives, a STUN Binding Indication is
used <xref target="RFC5389"/>. The Indication MUST NOT utilize any
authentication mechanism. It SHOULD contain the FINGERPRINT attribute
to aid in demultiplexing, but SHOULD NOT contain any other
attributes. It is used solely to keep the NAT bindings alive.  The
Binding Indication is sent using the same local and remote candidates
that are being used for data. Though Binding Indications are used for
keepalives, an agent MUST be prepared to receive a connectivity check
as well. If a connectivity check is received, a response is generated
as discussed in <xref target="RFC5389"/>, but there is no impact on
ICE processing otherwise.
</t>
<t>
Agents MUST by default use STUN keepalives. Individual ICE usages and
ICE extensions MAY specify usage/extension-specific keepalives.
</t>

</section>

<section title="Data Handling">

<section anchor="sec-send-media" title="Sending Data">

<t>
An ICE agent MAY send data on any valid pair before 
selected pairs have been produced for the data stream.
</t>

<t>
Once selected pairs have been produced for a data stream, an 
agent MUST send data on those pairs only.
</t>

<t>
An agent sends data from the base of the local candidate to the
remote candidate. In the case of a local relayed candidate, data
is forwarded through the base (located in the TURN server), 
using the procedures defined in <xref target="RFC5766"/>.
</t>

<t>
If the local candidate is a relayed candidate, it is RECOMMENDED that
an agent creates a channel on the TURN server towards the remote
candidate.  This is done using the procedures for channel creation as
defined in Section 11 of <xref target="RFC5766"/>.
</t>


<t>
The selected pair for a component of a data stream is:
<list style="symbols">
<t>
empty if the state of the check list for that data stream is Running,
and there is no previous selected pair for that component due to an
ICE restart
</t>

<t>
equal to the previous selected pair for a component of a data stream
if the state of the check list for that data stream is Running, and
there was a previous selected pair for that component due to an ICE
restart
</t>
</list>
</t>

<t>
Unless an agent is able to produce a selected pair for each component
associated with a data stream, the agent MUST NOT continue
sending data for any component associated with that data stream.
</t>

<section title="Procedures for Lite Implementations">

<t>
A lite implementation MUST NOT send data until it has a valid list
that contains a candidate pair for each component of that data
stream. Once that happens, the ICE agent MAY begin sending data
packets. To do that, it sends data to the remote candidate in the
pair (setting the destination address and port of the packet equal to
that remote candidate), and will send it from the base associated with the
candidate pair used for sending data. In case of a relayed
candidate, data is sent from the agent and forwarded through
the base (located in the TURN server), using the procedures defined
in <xref target="RFC5766"/>.
</t>

</section>
</section>

<section anchor="sec-recv-media" title="Receiving Data">

<t>
Even though ICE agents are only allowed to send data using valid
candidate pairs (and, once selected pairs have been produced, only
on the selected pairs) ICE implementations SHOULD by default be prepared
to receive data on any of the candidates provided in the most recent
candidate exchange with the peer. ICE usages MAY define rules
that differ from this, e.g., by defining that data will not be sent
until selected pairs have been produced for a data stream.
</t>

<t>It is
RECOMMENDED that, when an agent receives an RTP packet with a new
source or destination IP address for a particular RTP/RTCP data stream, that
the agent re-adjust its jitter buffers.
</t>

<t>
RFC 3550 <xref target="RFC3550"/> describes an algorithm in Section
8.2 for detecting synchronization source (SSRC) collisions and
loops. These algorithms are based, in part, on seeing different source
transport addresses with the same SSRC. However, when ICE is used,
such changes will sometimes occur as the data streams switch between
candidates. An agent will be able to determine that a data stream is
from the same peer as a consequence of the STUN exchange that proceeds
media data transmission. Thus, if there is a change in source transport
address, but the media data packets come from the same peer agent, this
MUST NOT be treated as an SSRC collision.
</t>

</section>
</section>

<section anchor="sec-futureproof" title="Extensibility Considerations">

<t>
This specification makes very specific choices about how both ICE agents
in a session coordinate to arrive at the set of candidate pairs that
are selected for data. It is anticipated that future specifications
will want to alter these algorithms, whether they are simple changes
like timer tweaks or larger changes like a revamp of the priority
algorithm. When such a change is made, providing interoperability
between the two agents in a session is critical.
</t>

<t>
First, ICE provides the ICE option concept. Each extension or
change to ICE is associated with an ICE option. When an agent supports
such an extension or change, it provides the ICE option to the peer agent
as part of the candidate exchange.
</t>

<t>
One of the complications in achieving interoperability is that ICE
relies on a distributed algorithm running on both agents to converge
on an agreed set of candidate pairs. If the two agents run different
algorithms, it can be difficult to guarantee convergence on the same
candidate pairs. The nomination procedure described in
<xref target="sec-conclude"/> eliminates some of the need for tight 
coordination by delegating the selection algorithm completely to the 
controlling agent, and ICE will converge perfectly even when both agents 
use different pair prioritization algorithms. One of the keys to such 
convergence is triggered checks, which ensure that the nominated pair is 
validated by both agents.
</t>

<t>
ICE is also extensible to other data streams beyond RTP, and for
transport protocols beyond UDP. Extensions to ICE for non-RTP data
streams need to specify how many components they utilize, and assign
component IDs to them, starting at 1 for the most important component
ID. Specifications for new transport protocols MUST define how, if at
all, various steps in the ICE processing differ from UDP.
</t>

</section>

<section anchor="sec-ta" title="Setting Ta and RTO">

<section anchor="sec-ta-gen" title="General">

<t>
During the ICE gathering phase (<xref target="sec-gathering"/>) and
while ICE is performing connectivity checks (<xref target="sec-connectivity_check"/>),
an ICE agent triggers STUN and TURN transactions. These transactions are paced at
a rate indicated by Ta, and the retransmission interval for each transaction
is calculated based on the the retransmission timer for the STUN transactions
(RTO) <xref target="RFC5389"/>.
</t>

<t>
This section describes how the Ta and RTO values are computed during the ICE
gathering phase and while ICE is performing connectivity checks.
</t>

<t>
NOTE: Previously, in RFC 5245, different formulas were defined for
computing Ta and RTO, depending on whether ICE was used for a real-time
data stream (e.g., RTP) or not.
</t>

<t>
The formulas below result in a behavior whereby an agent will send its first
packet for every single connectivity check before performing a
retransmit. This can be seen in the formulas for the RTO (which
represents the retransmit interval). Those formulas scale with N, the
number of checks to be performed. As a result of this, ICE maintains a
nicely constant rate, but becomes more sensitive to packet loss. The
loss of the first single packet for any connectivity check is likely
to cause that pair to take a long time to be validated, and instead, a
lower-priority check (but one for which there was no packet loss) is
much more likely to complete first. This results in ICE performing
sub-optimally, choosing lower-priority pairs over higher-priority
pairs.
</t>

</section>

<section anchor="sec-ta-ta" title="Ta">

<t>
ICE agents SHOULD use a default Ta value, 50 ms, but MAY use another
value based on the characteristics of the associated data.
</t>

<t>
If an agent wants to use another Ta value than the default value, the
agent MUST indicate the proposed value to its peer during the establishment
of the ICE session. Both agents MUST use the higher value of the proposed values.
If an agent does not propose a value, the default value is used for that
agent when comparing which value is higher.
</t>

<t>
Regardless of the Ta value chosen for each agent, the combination
of all transactions from all agents (if a given implementation
runs several concurrent agents) MUST NOT be sent more often than
once every 5ms (as though there were one global Ta value for pacing
all agents).
</t>

<t>
This mechanism of a global minimum pacing interval of 5ms is not
generally applicable to transport protocols, but is applicable to ICE
based on the following reasoning.

<list style="symbols">
  <t>Start with the following rules which would be generally
  applicable to transport protocols:
  <list style="numbers">
    <t>Let MaxBytes be the maximum number of bytes allowed to be
    outstanding in the network at start-up, which SHOULD be 14600,
    as defined in Section 2 of <xref target="RFC6928"/>.</t>
    <t>Let HTO be the transaction timeout, which SHOULD be 2*RTT if
    RTT is known and 500ms otherwise. This is based on the RTO for
    STUN messages from <xref target="RFC5389"/> and the the TCP initial RTO, which is
    1 sec in <xref target="RFC6298"/>.</t>
    <t>Let MinPacing be the minimum pacing interval between
    transactions, which is 5ms (see above).</t>
  </list>
  </t>
  <t>
    Observe that agents typically do not know the RTT for ICE
    transactions (connectivity checks in particular), meaning that HTO
    will almost always be 500ms.
  </t>
  <t>
    Observe that a MinPacing of 5ms and HTO of 500ms gives at most 100
    packets/HTO, which for a typical ICE check of less than 120
    bytes means a maximum of 12000 outstanding bytes in the network,
    which is less than the maximum expressed by rule 1.
  </t>
  <t>
    Thus, for ICE, the rule set reduces down to just the MinPacing
    rule, which is equivalent to having a global Ta value.
  </t>
</list>
</t>

<t>
NOTE: <xref target="sec-concheckbw"/> shows examples of required bandwidth,
using different Ta values.
</t>

</section>

<section anchor="sec-ta-rto" title="RTO">

<t>

During the ICE gathering phase, ICE agents SHOULD calculate the
RTO value using the following formula:
</t>

<figure><artwork>

<![CDATA[
  RTO = MAX (500ms, Ta * (Num-Of-Cands))


  Num-Of-Cands: the number of server-reflexive and relay candidates

]]></artwork></figure>

<t>
For connectivity checks, agents SHOULD calculate the RTO value
using the following formula:
</t>

<figure><artwork>

<![CDATA[
  RTO = MAX (500ms, Ta * N * (Num-Waiting + Num-In-Progress))

  N: the total number of connectivity checks to be performed.
  
  Num-Waiting: the number of checks in the check list set in the
  Waiting state.

  Num-In-Progress: the number of checks in the check list set in the 
  In-Progress state.

  Note that the RTO will be different for each transaction as the
  number of checks in the Waiting and In-Progress states change.

]]></artwork></figure>

<t>
Agents MAY calculate the RTO value using other mechanisms than those
described above. Agents MUST NOT use a RTO value smaller than 500 ms.
</t>

</section>

<!-- end Ta and RTO -->
</section>

<section anchor="sec-example" title="Examples">
<t>
This section shows two ICE examples: one using IPv4 addresses, and one using IPv6 addresses.
</t>

<t>
To facilitate understanding, transport addresses are listed using
variables that have mnemonic names. The format of the name is
entity-type-seqno, where entity refers to the entity whose IP address
the transport address is on, and is one of "L", "R", "STUN", or
"NAT". The type is either "PUB" for transport addresses that are
public, and "PRIV" for transport addresses that are private. Finally,
seq-no is a sequence number that is different for each transport
address of the same type on a particular entity. Each variable has an
IP address and port, denoted by varname.IP and varname.PORT,
respectively, where varname is the name of the variable. </t>

<t> In the call flow itself, STUN messages are annotated with several
attributes. The "S=" attribute indicates the source transport address
of the message. The "D=" attribute indicates the destination transport
address of the message. The "MA=" attribute is used in STUN Binding
response messages and refers to the mapped address. "USE-CAND" implies
the presence of the USE-CANDIDATE attribute.
</t>

<t>
The call flow examples omit STUN authentication operations,
and focus on a single data stream between two full
implementations.
</t>

<section anchor="sec-example-ipv4" title="Example with IPv4 Addresses">

<t>
The example is using the topology shown in <xref target="fig-ex-topo-ipv4"/>.
</t>

<figure title="Example Topology" anchor="fig-ex-topo-ipv4"><artwork>
<![CDATA[
                         +-------+
                         |STUN   |
                         |Server |
                         +-------+
                             |
                  +---------------------+
                  |                     |
                  |      Internet       |
                  |                     |
                  +---------------------+
                    |                |
                    |                |
             +---------+             |
             |   NAT    |             |
             +---------+             |
                  |                  |
                  |                  |
               +-----+            +-----+
               |  L  |            |  R  |
               +-----+            +-----+
]]></artwork></figure>

<t> In the example, ICE agents L and R are full ICE implementations. Both 
agents have a single IPv4 address. Both are configured with the same STUN server.
The NAT has an endpoint independent mapping property and an address dependent
filtering property. The IP addresses of the ICE agents, the STUN server and the NAT
are shown below;
</t>
<figure><artwork>
<![CDATA[

ENTITY                   IP Address  mnemonic name
--------------------------------------------------
ICE Agent L:             10.0.1.1    L-PRIV-1
ICE Agent R:             192.0.2.1   R-PUB-1          
STUN Server:             192.0.2.2   STUN-PUB-1
NAT (Public):            192.0.2.3   NAT-PUB-1
 
]]></artwork></figure>


<figure title="Example Flow" anchor="fig:basic-ex-ipv6"><artwork>
<![CDATA[
          L             NAT           STUN             R
          |STUN alloc.   |              |              |
          |(1) STUN Req  |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$STUN-PUB-1 |              |              |
          |------------->|              |              |
          |              |(2) STUN Req  |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$STUN-PUB-1 |              |
          |              |------------->|              |
          |              |(3) STUN Res  |              |
          |              |S=$STUN-PUB-1 |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |<-------------|              |
          |(4) STUN Res  |              |              |
          |S=$STUN-PUB-1 |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |<-------------|              |              |
          |(5) L's Candidate Information|              |
          |------------------------------------------->|
          |              |              |              | STUN
          |              |              |              | alloc.
          |              |              |(6) STUN Req  |
          |              |              |S=$R-PUB-1    |
          |              |              |D=$STUN-PUB-1 |
          |              |              |<-------------|
          |              |              |(7) STUN Res  |
          |              |              |S=$STUN-PUB-1 |
          |              |              |D=$R-PUB-1    |
          |              |              |MA=$R-PUB-1   |
          |              |              |------------->|
          |(8) R's Candidate Information|              |
          |<-------------------------------------------|
          |              |         (9) Bind Req        |Begin
          |              |         S=$R-PUB-1          |Connectivity
          |              |         D=$L-PRIV-1         |Checks
          |              |         <-------------------|
          |              |         Dropped             |
          |(10) Bind Req |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |------------->|              |              |
          |              |(11) Bind Req |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |---------------------------->|
          |              |(12) Bind Res |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |<----------------------------|
          |(13) Bind Res |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |<-------------|              |              |
          |              |              |              |
          |              |(14) Bind Req |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |<----------------------------|
          |(15) Bind Req |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |<-------------|              |              |
          |(16) Bind Res |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |MA=$R-PUB-1   |              |              |
          |------------->|              |              |
          |              |(17) Bind Res |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |MA=$R-PUB-1   |              |
          |              |---------------------------->|
          |              |              |              |
                             .......                  
          |              |              |              |
          |(18) Bind Req |              |              |
          |S=$L-PRIV-1   |              |              |
          |D=$R-PUB-1    |              |              |
          |USE-CAND      |              |              |
          |------------->|              |              |
          |              |(19) Bind Req |              |
          |              |S=$NAT-PUB-1  |              |
          |              |D=$R-PUB-1    |              |
          |              |USE-CAND      |              |
          |              |---------------------------->|
          |              |(20) Bind Res |              |
          |              |S=$R-PUB-1    |              |
          |              |D=$NAT-PUB-1  |              |
          |              |MA=$NAT-PUB-1 |              |
          |              |<----------------------------|
          |(21) Bind Res |              |              |
          |S=$R-PUB-1    |              |              |
          |D=$L-PRIV-1   |              |              |
          |MA=$NAT-PUB-1 |              |              |
          |<-------------|              |              |
          |              |              |              |
          
          
]]></artwork></figure>

<t>Messages 1-4: Agent L gathers a host candidate from its local IP address,
and from that sends a STUN Binding request to the STUN Server. The request
creates a NAT binding. The NAT public IP address of the binding becomes
agent L's server reflexive candidate.</t>

<t>Message 5: Agent L sends its local candidate information to agent R, using
the signalling protocol associated with the ICE usage.</t>

<t>Messages 6-7: Agent R gathers a host candidate from its local IP address,
and from that sends a STUN Binding request to the STUN Server. Since agent R
is not behind a NAT, R's server reflexive candidate will be identical to the
host candidate.

<t>Message 8: Agent R sends its local candidate information to agent L, using
the signalling protocol associated with the ICE usage.</t>

<t>Since both agents are full ICE implementations, the initiating agent (agent L)
becomes the controlling agent.</t>

<t>Agents L and R both pair up the candidates. Both agents initially have
two pairs. However, agent L will prune the pair containing its
server reflexive candidate, resulting in just one (L1). At agent L, this
pair has a local candidate of $L_PRIV_1 and remote candidate of
$R_PUB_1. At agent R, there are two pairs. The highest priority pair (R1)
has a local candidate of $R_PUB_1 and remote candidate of $L_PRIV_1, 
and the second pair (R2) has a local candidate of $R_PUB_1 and remote candidate 
of $NAT_PUB_1. The pairs are shown below (the pair numbers are for reference purpose 
only):
</t>

<figure><artwork>
<![CDATA[

                         Pairs
ENTITY                   Local         Remote     Pair #     Valid
------------------------------------------------------------------
ICE Agent L:             L_PRIV_1      R_PUB_1       L1

ICE Agent R:             R_PUB_1       L_PRIV_1      R1
                         R_PUB_1       NAT_PUB_1     R2 
 
]]></artwork></figure>

<t>Message 9: Agent R initiates a connectivity check for pair #2.
As the remote candidate of the pair is the private address of agent L,
the check will not be successful, as the request cannot be routed
from R to L, and will be dropped by the network.</t>

<t>Messages 10-13: Agent L initiates a connectivity check for pair L1.
The check succeeds, and L creates a new pair (L2). The local candidate
of the new pair is $NAT_PUB_1 and the remote candidate is $R_PUB_1. The
pair (L2) is added to the valid list of agent L.</t>

<figure><artwork>
<![CDATA[

                         Pairs
ENTITY                   Local         Remote     Pair #     Valid
------------------------------------------------------------------
ICE Agent L:             L_PRIV_1      R_PUB_1       L1
                         NAT_PUB_1     R_PUB_1       L2        X

ICE Agent R:             R_PUB_1       L_PRIV_1      R1
                         R_PUB_1       NAT_PUB_1     R2 
 
]]></artwork></figure>

<t>Messages 14-17: When agent R receives the Binding request from agent L
(message 11) it will initiate a triggered connectivity check. The pair
matches one of agent R's existing pairs (R2). The check succeeds, and the
pair (R2) is added to the valid list of agent R.</t> 

<figure><artwork>
<![CDATA[

                         Pairs
ENTITY                   Local         Remote     Pair #     Valid
------------------------------------------------------------------
ICE Agent L:             L_PRIV_1      R_PUB_1       L1
                         NAT_PUB_1     R_PUB_1       L2        X

ICE Agent R:             R_PUB_1       L_PRIV_1      R1
                         R_PUB_1       NAT_PUB_1     R2        X 
 
]]></artwork></figure>
.

<t>Messages 18-21: At some point, the controlling agent (agent L) decides 
to nominate a pair (L2) in the valid list. It performs a connectivity check 
on the pair (L2), and includes the USE-CANDIDATE attribute in the Binding request. 
As the check succeeds, agent L sets the nominated flag value of the pair (L2) to 'true'. 
Agent R sets the nominated flag value of the matching pair (R2) to 'true'. As there
are no more components associated with the stream, the nominated pairs become the 
selected pairs. Consequently, processing for this stream moves into the Completed state. 
The ICE process also moves into the Completed state.
</t>
</section>
<section anchor="sec-example-ipv6" title="Example with IPv6 Addresses">

<t>
The example is using the topology shown in <xref target="fig-ex-topo-ipv6"/>.
</t>

<figure title="Example Topology" anchor="fig-ex-topo-ipv6"><artwork>
<![CDATA[
                         +-------+
                         |STUN   |
                         |Server |
                         +-------+
                             |
                  +---------------------+
                  |                     |
                  |      Internet       |
                  |                     |
                  +---------------------+
                    |                |
                    |                |
                    |                |
                    |                |
                    |                |
                    |                |
                    |                |
                 +-----+          +-----+
                 |  L  |          |  R  |
                 +-----+          +-----+
]]></artwork></figure>

<t> In the example, ICE agents L and R are full ICE implementations. Both 
agents have a single IPv6 address. Both are configured with the same STUN server.
The IP addresses of the ICE agents and the STUN server are shown below;
</t>
<figure><artwork>
<![CDATA[

ENTITY                   IP Address  mnemonic name
--------------------------------------------------
ICE Agent L:             2001:db8::3   L-PUB-1
ICE Agent R:             2001:db8::5   R-PUB-1          
STUN Server:             2001:db8::9   STUN-PUB-1
 
]]></artwork></figure>


<figure title="Example Flow" anchor="fig:basic-ex-ipv6"><artwork>
<![CDATA[
          L                           STUN             R
          |STUN alloc.                  |              |
          |(1) STUN Req                 |              |
          |S=$L-PUB-1                   |              |
          |D=$STUN-PUB-1                |              |
          |---------------------------->|              | 
          |(2) STUN Res                 |              |
          | S=$STUN-PUB-1               |              |
          | D=$L-PUB-1                  |              |
          | MA=$L-PUB-1                 |              |
          |<----------------------------|              |
          |(3) L's Candidate Information|              |
          |------------------------------------------->|
          |                             |              | STUN
          |                             |              | alloc.
          |                             |(4) STUN Req  |
          |                             |S=$R-PUB-1    |
          |                             |D=$STUN-PUB-1 |
          |                             |<-------------|
          |                             |(5) STUN Res  |
          |                             |S=$STUN-PUB-1 |
          |                             |D=$R-PUB-1    |
          |                             |MA=$R-PUB-1   |
          |                             |------------->|
          |(6) R's Candidate Information|              |
          |<-------------------------------------------|
          |(7) Bind Req                 |              |
          |S=$L-PUB-1                   |              |
          |D=$R-PUB-1                   |              |
          |------------------------------------------->|
          |(8) Bind Res                 |              |
          |S=$R-PUB-1                   |              |
          |D=$L-PUB-1                   |              |
          |MA=$L-PUB-1                  |              |
          |<-------------------------------------------| 
          |                             |              |
          |(9) Bind Req                 |              |
          |S=$R-PUB-1                   |              |
          |D=$L-PUB-1                   |              |
          |<-------------------------------------------|
          |(10) Bind Res                |              |
          |S=$L-PUB-1                   |              |
          |D=$R-PUB-1                   |              |
          |MA=$R-PUB-1                  |              |
          |------------------------------------------->|
          |                             |              |
                             .......                  
          |                             |              |
          |(11) Bind Req                |              |
          |S=$L-PUB-1                   |              |
          |D=$R-PUB-1                   |              |
          |USE-CAND                     |              |
          |------------------------------------------->|
          |(12) Bind Res                |              |
          |S=$R-PUB-1                   |              |
          |D=$L-PUB-1                   |              |
          |MA=$L-PUB-1                  |              |
          |<-------------------------------------------| 
          |              |              |              |
          
          
]]></artwork></figure>

<t>Messages 1-2: Agent L gathers a host candidate from its local IP address,
and from that sends a STUN Binding request to the STUN Server. Since agent L
is not behind a NAT, L's server reflexive candidate will be identical to the
host candidate.</t>

<t>Message 3: Agent L sends its local candidate information to agent R, using
the signalling protocol associated with the ICE usage.</t>

<t>Messages 4-5: Agent R gathers a host candidate from its local IP address,
and from that sends a STUN Binding request to the STUN Server. Since agent R
is not behind a NAT, R's server reflexive candidate will be identical to the
host candidate.

<t>Message 6: Agent R sends its local candidate information to agent L, using
the signalling protocol associated with the ICE usage.</t>

<t>Since both agents are full ICE implementations, the initiating agent (agent L)
becomes the controlling agent.</t>

<t>Agents L and R both pair up the candidates. Both agents initially have
one pair each. At agent L, the pair (L1) has a local candidate of $L_PUB_1 
and remote candidate of $R_PUB_1. At agent R, the pair (R1) has a local candidate 
of $R_PUB_1 and remote candidate of $L_PUB_1. The pairs are shown below 
(the pair numbers are for reference purpose only):
</t>

<figure><artwork>
<![CDATA[

                         Pairs
ENTITY                   Local         Remote     Pair #     Valid
------------------------------------------------------------------
ICE Agent L:             L_PUB_1       R_PUB_1       L1

ICE Agent R:             R_PUB_1       L_PUB_1       R1
 
]]></artwork></figure>

<t>Messages 7-8: Agent L initiates a connectivity check for pair L1.
The check succeeds, and the pair (L1) is added to the valid list of agent L.</t>

<figure><artwork>
<![CDATA[

                         Pairs
ENTITY                   Local         Remote     Pair #     Valid
------------------------------------------------------------------
ICE Agent L:             L_PUB_1       R_PUB_1       L1         X

ICE Agent R:             R_PUB_1       L_PUB_1       R1
 
]]></artwork></figure>

<t>Messages 9-10: When agent R receives the Binding request from agent L
(message 7) it will initiate a triggered connectivity check. The pair
matches agent R's existing pair (R1). The check succeeds, and the
pair (R1) is added to the valid list of agent R.</t> 

<figure><artwork>
<![CDATA[

                         Pairs
ENTITY                   Local         Remote     Pair #     Valid
------------------------------------------------------------------
ICE Agent L:             L_PUB_1       R_PUB_1       L1         X

ICE Agent R:             R_PUB_1       L_PUB_1       R1         X
 
]]></artwork></figure>
.

<t>Messages 11-12: At some point, the controlling agent (agent L) decides 
to nominate a pair (L1) in the valid list. It performs a connectivity check 
on the pair (L1), and includes the USE-CANDIDATE attribute in the Binding request. 
As the check succeeds, agent L sets the nominated flag value of the pair (L1) to 'true'. 
Agent R sets the nominated flag value of the matching pair (R1) to 'true'. As there
are no more components associated with the stream, the nominated pairs become the 
selected pairs. Consequently, processing for this stream moves into the Completed state. 
The ICE process also moves into the Completed state.
</t>
</section>
</section>

<section title="STUN Extensions">

<section anchor="sec-ice-newatts" title="New Attributes">

<t>
This specification defines four STUN attributes: PRIORITY,
USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.
</t>

<t>
The PRIORITY attribute indicates the priority that is to be
associated with a peer reflexive candidate, if one will be discovered
by this check. It is a 32-bit unsigned integer, and has an attribute
value of 0x0024.
</t>

<t>
The USE-CANDIDATE attribute indicates that the candidate pair
resulting from this check will be used for transmission of
data. The attribute has no content (the Length field of the attribute
is zero); it serves as a flag. It has an attribute value of 0x0025.
</t>

<t>
The ICE-CONTROLLED attribute is present in a Binding request. The attribute
indicates that the client believes it is currently in the controlled
role. The content of the attribute is a 64-bit unsigned integer in
network byte order, which contains a random number. The number is used
for solving role conflicts, when it is referred to as the tie-breaker
value. An ICE agent MUST use the same number for all Binding requests,
for all streams, within an ICE session. The agent MAY change
the number when an ICE restart occurs.
</t>

<t>
The ICE-CONTROLLING attribute is present in a Binding request. The attribute
indicates that the client believes it is currently in the controlling
role. The content of the attribute is a 64-bit unsigned integer in
network byte order, which contains a random number. As for the
ICE-CONTROLLED attribute, the number is used for solving role conflicts. 
An agent MUST use the same number for all Binding requests, for all streams, 
within an ICE session. The agent MAY change the number when an ICE restart occurs.
</t>

</section>

<section title="New Error Response Codes">

<t>This specification defines a single error response code:</t>

<t><list style="hanging">

<t hangText="487 (Role Conflict):"> The Binding request contained
either the ICE-CONTROLLING or ICE-CONTROLLED attribute, indicating an
ICE role that conflicted with the server. The remote server compared the
tie-breaker values of the client and the server and determined that
the client needs to switch roles.  </t>

</list></t>

</section>

</section>

<section title="Operational Considerations">

<t>
This section discusses issues relevant to operators operating networks where 
ICE will be used by endpoints.
</t>

<section title="NAT and Firewall Types">

<t>
ICE was designed to work with existing NAT and firewall
equipment. Consequently, it is not necessary to replace or reconfigure
existing firewall and NAT equipment in order to facilitate deployment
of ICE. Indeed, ICE was developed to be deployed in environments where
the Voice over IP (VoIP) operator has no control over the IP network
infrastructure, including firewalls and NATs.
</t>

<t>
That said, ICE works best in environments where the NAT devices are
"behave" compliant, meeting the recommendations defined in <xref
target="RFC4787"/> and <xref target="RFC5382"/>. In networks with
behave-compliant NAT, ICE will work without the need for a TURN
server, thus improving voice quality, decreasing call setup times, and
reducing the bandwidth demands on the network operator.
</t>

</section>

<section title="Bandwidth Requirements">

<t>
Deployment of ICE can have several interactions with available network
capacity that operators need to take into consideration.
</t>

<section title="STUN and TURN Server Capacity Planning">

<t>
First and foremost, ICE makes use of TURN and STUN servers, which
would typically be located in data centers. The
STUN servers require relatively little bandwidth. For each component
of each data stream, there will be one or more STUN transactions from
each client to the STUN server. In a basic voice-only IPv4 VoIP
deployment, there will be four transactions per call (one for RTP and
one for RTCP, for both caller and callee). Each transaction
is a single request and a single response, the former being 20 bytes
long, and the latter, 28. Consequently, if a system has N users, and
each makes four calls in a busy hour, this would require N*1.7bps. For
one million users, this is 1.7 Mbps, a very small number (relatively
speaking).
</t>

<t>
TURN traffic is more substantial. The TURN server will see traffic
volume equal to the STUN volume (indeed, if TURN servers are deployed,
there is no need for a separate STUN server), in addition to the
traffic for the actual data. The amount of calls requiring
TURN for data relay is highly dependent on network topologies, and
can and will vary over time. In a network with 100% behave-compliant
NATs, it is exactly zero.
</t>

<t>
The planning considerations above become more significant in multi-media
scenarios (e.g., audio and video conferences), and when the numbers of
participants in a session grow.
</t>


</section>

<section title="Gathering and Connectivity Checks">

<t>
The process of gathering of candidates and performing of connectivity
checks can be bandwidth intensive. ICE has been designed to pace both
of these processes. The gathering phase and the connectivity check phase 
are meant to generate traffic at roughly the same bandwidth as the data 
traffic itself will consume once the ICE process conclude. This was done 
to ensure that, if a network is designed to support communication traffic 
of a certain type (voice, video, or just text), it will have sufficient 
capacity to support the ICE checks for that data. Once ICE has concluded, 
the subsequent ICE keep-alives will later cause a marginal increase in the 
total bandwidth utilization; however, this will typically be an extremely 
small increase.
</t>

<t>
Congestion due to the gathering and check phases has proven to be a
problem in deployments that did not utilize pacing. Typically, access
links became congested as the endpoints flooded the network with
checks as fast as they can send them. Consequently, network operators
need to ensure that their ICE implementations support the pacing
feature. Though this pacing does increase call setup times, it makes
ICE network friendly and easier to deploy.
</t>

</section>

<section title="Keepalives">

<t>
STUN keepalives (in the form of STUN Binding Indications) are sent in
the middle of a data session. However, they are sent only in the
absence of actual data traffic. In deployments with continuous media 
and without utilizing Voice Activity Detection (VAD), or deployments where 
VAD is utilized together with short interval (max 1 second) comfort noise,
the keepalives are never used and there is no increase in bandwidth usage.
When VAD is being used without comfort noise, keepalives will be sent during 
silence periods. This involves a single packet every 15-20 seconds, far less 
than the packet every 20-30 ms that is sent when there is voice. Therefore, 
keepalives do not have any real impact on capacity planning.
</t>

</section>

</section>

<section title="ICE and ICE-lite">

<t>
Deployments utilizing a mix of ICE and ICE-lite interoperate
with each other. They have been explicitly designed to do so.
</t>

<t>
However, ICE-lite can only be deployed in limited use cases. Those
cases, and the caveats involved in doing so, are documented in
<xref target="sec-liteandfull"/>.
</t>

</section>

<section title="Troubleshooting and Performance Management">

<t>
ICE utilizes end-to-end connectivity checks, and places much of the
processing in the endpoints. This introduces a challenge to the
network operator -- how can they troubleshoot ICE deployments? How can
they know how ICE is performing?
</t>

<t>
ICE has built-in features to help deal with these problems. Signaling
servers, typically deployed in data centers
of the network operator, will see the contents of the candidate
exchanges that convey the ICE parameters. These parameters include the
type of each candidate (host, server reflexive, or relayed), along
with their related addresses. Once ICE processing has completed, an
updated candidate exchange takes place, signaling the selected
address (and its type). This updated signaling is performed exactly
for the purposes of educating network equipment (such as a diagnostic
tool attached to a signaling) about the results of ICE processing.
</t>

<t>
As a consequence, through the logs generated by a signaling server, a
network operator can observe what types of candidates are being used
for each call, and what address were selected by ICE. This is the
primary information that helps evaluate how ICE is performing.
</t>

</section>

<section title="Endpoint Configuration">

<t>
ICE relies on several pieces of data being configured into the
endpoints. This configuration data includes timers, credentials for
TURN servers, and hostnames for STUN and TURN servers. ICE itself does
not provide a mechanism for this configuration. Instead, it is assumed
that this information is attached to whatever mechanism is used to
configure all of the other parameters in the endpoint. For SIP phones,
standard solutions such as the configuration framework
<xref target="RFC6080"/> have been defined.
</t>

</section>

</section>

<section anchor="sec-iab" title="IAB Considerations">

<t>
The IAB has studied the problem of "Unilateral Self-Address Fixing" (UNSAF),
which is the general process by which an ICE agent attempts to determine
its address in another realm on the other side of a NAT through a
collaborative protocol reflection mechanism <xref target="RFC3424"/>.
ICE is an example of a protocol that performs this type of
function. Interestingly, the process for ICE is not unilateral, but
bilateral, and the difference has a significant impact on the issues
raised by the IAB. Indeed, ICE can be considered a B-SAF (Bilateral
Self-Address Fixing) protocol, rather than an UNSAF
protocol. Regardless, the IAB has mandated that any protocols
developed for this purpose document a specific set of
considerations. This section meets those requirements.
</t>

<section title="Problem Definition">

<t>
From RFC 3424, any UNSAF proposal needs to provide:
</t>

<t><list style="hanging">
<t>
Precise definition of a specific, limited-scope problem that is to be
solved with the UNSAF proposal. A short-term fix will not be
generalized in order to solve other problems; this is why "short-term 
fixes usually aren't".
</t>
</list></t>

<t>
The specific problems being solved by ICE are:
</t>

<t><list style="hanging">

<t>
Provide a means for two peers to determine the set of transport
addresses that can be used for communication.
</t>

<t>
Provide a means for a agent to determine an address that is
reachable by another peer with which it wishes to communicate.
</t>

</list></t>

</section>

<section title="Exit Strategy">

<t>
From RFC 3424, any UNSAF proposal needs to provide:
</t>

<t><list style="hanging"><t>
Description of an exit strategy/transition plan.  The better
short-term fixes are the ones that will naturally see less and
less use as the appropriate technology is deployed.
</t></list></t>

<t> ICE itself doesn't easily get phased out. However, it is useful
even in a globally connected Internet, to serve as a means for
detecting whether a router failure has temporarily disrupted
connectivity, for example. ICE also helps prevent certain security
attacks that have nothing to do with NAT. However, what ICE does is
help phase out other UNSAF mechanisms. ICE effectively picks amongst
those mechanisms, prioritizing ones that are better, and
deprioritizing ones that are worse. IPv6 address from the local host 
can be preferred. As NATs begin to dissipate as IPv6 is introduced, server
reflexive and relayed candidates (both forms of UNSAF addresses)
simply never get used, because higher-priority connectivity exists to
the native host candidates. Therefore, the servers get used less and
less, and can eventually be removed when their usage goes to zero.
</t>

<t>
Indeed, ICE can assist in the transition from IPv4 to IPv6. It can be
used to determine whether to use IPv6 or IPv4 when two dual-stack
hosts communicate with SIP (IPv6 gets used). It can also allow a
network with both 6to4 and native v6 connectivity to determine which
address to use when communicating with a peer.
</t>

</section>

<section title="Brittleness Introduced by ICE">

<t>
From RFC 3424, any UNSAF proposal needs to provide:
</t>

<t><list style="hanging"><t>
Discussion of specific issues that may render systems more
"brittle".  For example, approaches that involve using data at
multiple network layers create more dependencies, increase
debugging challenges, and make it harder to transition.
</t></list></t>

<t> ICE actually removes brittleness from existing UNSAF
mechanisms. In particular, classic STUN (as described in RFC 3489
<xref target="RFC3489"/>) has several points of brittleness. One of
them is the discovery process that requires an ICE agent to try to
classify the type of NAT it is behind. This process is
error-prone. With ICE, that discovery process is simply not
used. Rather than unilaterally assessing the validity of the address,
its validity is dynamically determined by measuring connectivity to a
peer. The process of determining connectivity is very robust.  </t>

<t>
Another point of brittleness in classic STUN and any other unilateral
mechanism is its absolute reliance on an additional server. ICE makes
use of a server for allocating unilateral addresses, but allows
agents to directly connect if possible. Therefore, in some cases, the
failure of a STUN server would still allow for a call to
progress when ICE is used.
</t>

<t>
Another point of brittleness in classic STUN is that it assumes
that the STUN server is on the public Internet. Interestingly, with
ICE, that is not necessary. There can be a multitude of STUN servers
in a variety of address realms. ICE will discover the one that has
provided a usable address.
</t>

<t>
The most troubling point of brittleness in classic STUN is that it
doesn't work in all network topologies. In cases where there is a
shared NAT between each agent and the STUN server, traditional STUN
may not work. With ICE, that restriction is removed.
</t>

<t>
Classic STUN also introduces some security
considerations. Fortunately, those security considerations are also
mitigated by ICE.
</t>

<t>
Consequently, ICE serves to repair the brittleness introduced in
classic STUN, and does not introduce any additional brittleness
into the system.
</t>

<t>
The penalty of these improvements is that ICE increases session
establishment times.
</t>

</section>

<section title="Requirements for a Long-Term Solution">

<t>From RFC 3424, any UNSAF proposal needs to provide:
</t>

<t><list style="hanging"><t>
... requirements for longer term, sound technical solutions
-- contribute to the process of finding the right longer term
solution.
</t>
</list></t>

<t>
Our conclusions from RFC 3489 remain unchanged. However, we feel ICE
actually helps because we believe it can be part of the long-term
solution.
</t>

</section>

<section title="Issues with Existing NAPT Boxes">

<t>From RFC 3424, any UNSAF proposal needs to provide:
</t>

<t><list style="hanging"><t>
Discussion of the impact of the noted practical issues with
existing, deployed NA[P]Ts and experience reports.
</t></list></t>

<t>
A number of NAT boxes are now being deployed into the market that try
to provide "generic" ALG functionality. These generic ALGs hunt for IP
addresses, either in text or binary form within a packet, and rewrite
them if they match a binding. This interferes with classic
STUN. However, the update to STUN <xref target="RFC5389"/> uses an
encoding that hides these binary addresses from generic ALGs.
</t>

<t>
Existing NAPT boxes have non-deterministic and typically short
expiration times for UDP-based bindings. This requires implementations
to send periodic keepalives to maintain those bindings. ICE uses a
default of 15 s, which is a very conservative estimate. Eventually,
over time, as NAT boxes become compliant to behave <xref
target="RFC4787"/>, this minimum keepalive will become deterministic
and well-known, and the ICE timers can be adjusted. Having a way to
discover and control the minimum keepalive interval would be far
better still.
</t>

</section>

</section>

<section anchor="sec-security" title="Security Considerations">
<section title="IP Address Privacy">
<t>
The process of probing for candidates reveals the source addresses of
the client and its peer to any on-network listening attacker, and the
process of exchanging candidates reveals the addresses to any attacker
that is able to see the negotiation. Some addresses, such as the server
reflexive addresses gathered through the local interface of VPN users,
may be sensitive information. If these potential attacks can not be 
mitigated, ICE usages can define mechanisms for controlling which addresses 
are revealed to the negotiation and/or probing process. Individual implementations
may also have implementation-specific rules for controlling which addresses 
are revealed. For example, <xref target="I-D.ietf-rtcweb-ip-handling"/> provides 
additional information about the privacy aspects of revealing IP addresses
via ICE for WebRTC applications. ICE implementations where such issues can arise 
are RECOMMENDED to provide a programmatic or user interface that provides control 
over which network interfaces are used to generate candidates.
</t>
<t>
Based on the types of candidates provided by the peer, and the
results of the connectivity tests performed against those candidates,
the peer might be able to determine characteristics of the local
network, e.g. if different timings are apparent to the peer. In
the limit the peer might be able to probe the local network.
</t>
<t>
There are several types of attacks possible in an ICE system. The
subsections consider these attacks and their countermeasures.
</t>
</section>
<section title="Attacks on Connectivity Checks">

<t>
An attacker might attempt to disrupt the STUN connectivity
checks. Ultimately, all of these attacks fool an ICE agent into thinking
something incorrect about the results of the connectivity checks. The
possible false conclusions an attacker can try and cause are:
</t>

<t><list style="hanging">

<t hangText="False Invalid:">An attacker can fool a pair of agents
into thinking a candidate pair is invalid, when it isn't. This can be
used to cause an agent to prefer a different candidate (such as one
injected by the attacker) or to disrupt a call by forcing all
candidates to fail.
</t>

<t hangText="False Valid:">An attacker can fool a pair of agents into
thinking a candidate pair is valid, when it isn't. This can cause an
agent to proceed with a session, but then not be able to receive any
data.
</t>

<t hangText="False Peer Reflexive Candidate:">An attacker can cause an
agent to discover a new peer reflexive candidate when it is not expected
to. This can be used to redirect data streams to a
Denial-of-Service (DoS) target or to the attacker, for eavesdropping
or other purposes.
</t>

<t hangText="False Valid on False Candidate:">An attacker has already
convinced an agent that there is a candidate with an address that
does not actually route to that agent (for example, by injecting a
false peer reflexive candidate or false server reflexive
candidate). The attacker then launches an attack that forces the agents to
believe that this candidate is valid.
</t>

<t>
If an attacker can cause a false peer reflexive candidate or false
valid on a false candidate, it can launch any of the attacks described
in <xref target="RFC5389"/>.
</t>

</list></t>

<t> To force the false invalid result, the attacker has to wait for
the connectivity check from one of the agents to be sent. When it is,
the attacker needs to inject a fake response with an unrecoverable
error response, such as a 400. However, since the candidate is, in
fact, valid, the original request may reach the peer agent, and result
in a success response. The attacker needs to force this packet or its
response to be dropped, through a DoS attack, layer 2 network
disruption, or other technique. If it doesn't do this, the success
response will also reach the originator, alerting it to a possible
attack. Fortunately, this attack is mitigated completely through the
STUN short-term credential mechanism. The attacker needs to inject a
fake response, and in order for this response to be processed, the
attacker needs the password. If the candidate exchange signaling is
secured, the attacker will not have the password and its response will
be discarded.
</t>

<t>
Spoofed ICMP Hard Errors (Type 3, codes 2-4) can also be used to
create false invalid results. If an ICE agent implements a response
to these ICMP errors, and the attacker is capable of generating an
ICMP message that is delivered to the agent sending the connectivity
check. The validation of the ICMP error message by the agent is its
only defence. For Type 3 code=4 the outer IP header provides no
validation, unless the connectivity check was sent with DF=0.
For code 2 or 3, which are originated by the host, the
address is expected to be any of the remote agents host, reflexive,
or relay candidates IP addresses. The ICMP message include the IP header and UDP
header of the message triggering the error. These fields also need to
be validated. The IP destination and UDP destination port need to match
either the targeted candidate address and port, or the candidate's base
address. The source IP address and port can be any candidate for the
same base address of the agent sending the connectivity check. Thus any
attacker having access to the exchange of the candidates will have the necessary
information. Thus the validation is a weak defence, and the sending of
spoofed ICMP attacks is possible also for off-path attackers from a node
in a network without source address validation.
</t>

<t> Forcing the fake valid result works in a similar way. The agent
needs to wait for the Binding request from each agent, and inject a
fake success response. The attacker won't need to worry about
disrupting the actual response since, if the candidate is not valid,
it presumably wouldn't be received anyway. However, like the fake
invalid attack, this attack is mitigated by the STUN short-term
credential mechanism in conjunction with a secure candidate exchange.
</t>

<t>Forcing the false peer reflexive candidate result can be done
either with fake requests or responses, or with replays. We consider
the fake requests and responses case first. It requires the attacker
to send a Binding request to one agent with a source IP address and
port for the false candidate. In addition, the attacker needs to wait for
a Binding request from the other agent, and generate a fake response
with a XOR-MAPPED-ADDRESS attribute containing the false
candidate. Like the other attacks described here, this attack is
mitigated by the STUN message integrity mechanisms and secure
candidate exchanges.
</t>

<t>Forcing the false peer reflexive candidate result with packet
replays is different. The attacker waits until one of the agents sends
a check. It intercepts this request, and replays it towards the other
agent with a faked source IP address. It also needs to prevent the
original request from reaching the remote agent, either by launching a
DoS attack to cause the packet to be dropped, or forcing it to be
dropped using layer 2 mechanisms. The replayed packet is received at
the other agent, and accepted, since the integrity check passes (the
integrity check cannot and does not cover the source IP address and
port). It is then responded to. This response will contain a
XOR-MAPPED-ADDRESS with the false candidate, and will be sent to that
false candidate.  The attacker then needs to receive it and relay it
towards the originator.
</t>

<t>The other agent will then initiate a connectivity check towards
that false candidate. This validation needs to succeed. This requires
the attacker to force a false valid on a false candidate. Injecting of
fake requests or responses to achieve this goal is prevented using the
integrity mechanisms of STUN and the candidate exchange. Thus, this
attack can only be launched through replays. To do that, the attacker
needs to intercept the check towards this false candidate, and replay it
towards the other agent. Then, it needs to intercept the response and
replay that back as well.  </t>

<t>
This attack is very hard to launch unless the attacker is identified
by the fake candidate. This is because it requires the attacker to
intercept and replay packets sent by two different hosts. If both
agents are on different networks (for example, across the public
Internet), this attack can be hard to coordinate, since it needs to
occur against two different endpoints on different parts of the
network at the same time.
</t>

<t>
If the attacker itself is identified by the fake candidate, the attack
is easier to coordinate. However, if the data path is secured (e.g.,
using SRTP <xref target="RFC3711"/>), the attacker will not be able to
process the data packets, but will only be able to discard them,
effectively disabling the data stream. However, this
attack requires the agent to disrupt packets in order to block the
connectivity check from reaching the target. In that case, if the goal
is to disrupt the data stream, it's much easier to just disrupt it
with the same mechanism, rather than attack ICE.
</t>

</section>

<section title="Attacks on Server Reflexive Address Gathering">

<t>
ICE endpoints make use of STUN Binding requests for gathering server
reflexive candidates from a STUN server. These requests are not
authenticated in any way. As a consequence, there are numerous
techniques an attacker can employ to provide the client with a false
server reflexive candidate:

<list style="symbols">
<t>An attacker can compromise the DNS, causing DNS queries to return a
  rogue STUN server address. That server can provide the client with
  fake server reflexive candidates. This attack is mitigated by DNS
  security, though DNSSEC is not required to address it.
</t>

<t>
  An attacker that can observe STUN messages (such as an attacker on a
  shared network segment, like WiFi) can inject a fake response that
  is valid and will be accepted by the client.
</t>

<t>
  An attacker can compromise a STUN server, and
  cause it to send responses with incorrect mapped addresses.
</t>
</list>

</t>

<t>
A false mapped address learned by these attacks will be used as a
server reflexive candidate in the establishment of the ICE session. For this candidate to
actually be used for data, the attacker also needs to attack the
connectivity checks, and in particular, force a false valid on a false
candidate. This attack is very hard to launch if the false address
identifies a fourth party (neither the initiator, responder, nor
attacker), since it requires attacking the checks generated by each
ICE agent in the session, and is prevented by SRTP if it identifies the
attacker itself.
</t>

<t>If the attacker elects not to attack the connectivity checks, the
worst it can do is prevent the server reflexive candidate from being
used. However, if the peer agent has at least one candidate that is
reachable by the agent under attack, the STUN connectivity checks
themselves will provide a peer reflexive candidate that can be used
for the exchange of data. Peer reflexive candidates are generally
preferred over server reflexive candidates. As such, an attack solely
on the STUN address gathering will normally have no impact on a session
at all.  </t>

</section>

<section title="Attacks on Relayed Candidate Gathering">

<t>
An attacker might attempt to disrupt the gathering of relayed
candidates, forcing the client to believe it has a false relayed
candidate. Exchanges with the TURN server are authenticated using a
long-term credential. Consequently, injection of fake responses or
requests will not work. In addition, unlike Binding requests, Allocate
requests are not susceptible to replay attacks with modified source IP
addresses and ports, since the source IP address and port are not
utilized to provide the client with its relayed candidate.
</t>

<t>
Even if an attacker has caused the client to believe in a false
relayed candidate, the connectivity checks cause such a candidate to
be used only if they succeed. Thus, an attacker needs to launch a false
valid on a false candidate, per above, which is a very difficult
attack to coordinate.
</t>

</section>

<section title="Insider Attacks">

<t>
In addition to attacks where the attacker is a third party trying to
insert fake candidate information or STUN messages, there are attacks
possible with ICE when the attacker is an authenticated and valid
participant in the ICE exchange.
</t>

<section anchor="sec-ice-hammer" title="STUN Amplification Attack">

<t>
The STUN amplification attack is similar to a "voice hammer" attack, where
the attacker causes other agents to direct voice packets to the
attack target. However, instead of voice packets being directed to the target, 
STUN connectivity checks are directed to the target. The attacker sends an
a large number of candidates, say, 50. The responding agent receives
the candidate information, and starts its checks, which are directed
at the target, and consequently, never generate a response. The
answerer will start a new connectivity check every Ta ms (say,
Ta=50ms). However, the retransmission timers are set to a large number
due to the large number of candidates. As a consequence, packets will
be sent at an interval of one every Ta milliseconds, and then with
increasing intervals after that. Thus, STUN will not send packets at a
rate faster than data would be sent, and the STUN packets persist
only briefly, until ICE fails for the session. Nonetheless, this is an
amplification mechanism.
</t>

<t>
It is impossible to eliminate the amplification, but the volume can be
reduced through a variety of heuristics. ICE agents SHOULD limit the total
number of connectivity checks they perform to 100. Additionally,
agents MAY limit the number of candidates they will accept.
</t>

<t>
Frequently, protocols that wish to avoid these kinds of attacks force
the initiator to wait for a response prior to sending the next
message. However, in the case of ICE, this is not possible. It is not
possible to differentiate the following two cases:
<list style="symbols">
<t>There was no response because the initiator is being used to launch
  a DoS attack against an unsuspecting target that will not respond.
</t>
<t>There was no response because the IP address and port are not
  reachable by the initiator.
</t>
</list>
In the second case, another check will be sent at the next
opportunity, while in the former case, no further checks will be
sent.
</t>


</section>

</section>



</section>


<section title="IANA Considerations">

<t>
The original ICE specification registered four STUN attributes,
and one new STUN error response. The STUN attributes and error
response are reproduced here. In addition, this specification
registers a new ICE option.
</t>


<section title="STUN Attributes">

<t>
IANA has registered four STUN attributes:
</t>

<figure><artwork>
<![CDATA[
   0x0024 PRIORITY
   0x0025 USE-CANDIDATE
   0x8029 ICE-CONTROLLED
   0x802A ICE-CONTROLLING
]]></artwork></figure>

<t>NOTE TO IANA: Please replace the reference to RFC 5245 in the registry
with a reference to this specification.</t>

</section>

<section title="STUN Error Responses">

<t>
IANA has registered following STUN error response code:
</t>

<figure><artwork>
<![CDATA[
 487   Role Conflict: The client asserted an ICE role (controlling or
       controlled) that is in conflict with the role of the server.
]]></artwork></figure>

<t>NOTE TO IANA: Please replace the reference to RFC 5245 in the registry
with a reference to this specification.</t>

</section>

<section title="ICE Options">

<t>
IANA is requested to register the following ICE option in the "ICE Options"
sub-registry of the "Interactive Connectivity Establishment (ICE) registry",
following the procedures defined in <xref target="RFC6336"/>.
</t>

<figure><artwork>
<![CDATA[

ICE Option name:

     ice2

  Contact:

     Name:    Christer Holmberg
     E-mail:  christer.holmberg(at)ericsson(dot)com
     Address: Oy LM Ericsson Ab, 02420 Jorvas, FINLAND

  Change control:

     IESG

  Description:

     The ICE option indicates that the ICE agent using the ICE option
     is implemented according to RFC XXXX.

  Reference:

     RFC XXXX

]]></artwork></figure>


</section>

</section>

<section title="Changes from RFC 5245">

<t> The purpose of this updated ICE specification is to:
<list style="symbols">
<t>Clarify procedures in RFC 5245.</t>
<t>Make technical changes, due to discovered flaws in RFC 5245 and based
on feedback from the community that has implemented and
deployed ICE applications based on RFC 5245.</t>
<t>Make the procedures signaling protocol independent, by
removing the SIP and SDP procedures. Procedures specific
to a signaling protocol will be defined in separate usage
documents. <xref target="I-D.ietf-mmusic-ice-sip-sdp"/> defines
the ICE usage with SIP and SDP.</t>
</list>
</t>

<t> The following technical changes have been done:
<list style="symbols">
<t>Aggressive nomination removed.</t>
<t>The procedures for calculating candidate pair states
and scheduling connectivity checks modified.</t>
<t>Procedures for calculation of Ta and RTO modified.</t>
<t>Active check list and frozen check list definitions removed.</t>
<t>'ice2' ice option added.</t>
<t>IPv6 considerations modified.</t>
<t>Usage with no-op for keepalives, and keepalives with non-ICE
peers, removed.</t>
</list>
</t>
</section>

<section title="Acknowledgements">

<t> Most of the text in this document comes from the original ICE
specification, RFC 5245. The authors would like to thank everyone who
has contributed to that document. For additional contributions to this
revision of the specification we would like to thank Emil Ivov, Paul
Kyzivat, Pal-Erik Martinsen, Simon Perrault, Eric Rescorla, Thomas
Stach, Peter Thatcher, Martin Thomson, Justin Uberti, Suhas
Nandakumar, Taylor Brandstetter, Peter Saint-Andre, Harald Alvestrand
and Roman Shpount. Ben Campbell did the AD review. Stephen Farrell did 
the sec-dir review. Stewart Bryant did the gen-art review. Qin We did 
the ops-dir review. Magnus Westerlund did the tsv-art review.</t>

</section>

</middle>

<back>
<references title="Normative References">
<?rfc include="reference.RFC.2119"?>
<?rfc include="reference.RFC.4941"?>
<?rfc include="reference.RFC.5389"?>
<?rfc include="reference.RFC.5766"?>
<?rfc include="reference.RFC.6336"?>
<?rfc include="reference.RFC.6724"?>
</references>

<references title="Informative References">
<?rfc include="reference.RFC.3605"?>
<?rfc include="reference.RFC.3261"?>
<?rfc include="reference.RFC.3264"?>
<?rfc include="reference.RFC.3489"?>
<?rfc include="reference.RFC.3235"?>
<?rfc include="reference.RFC.3303"?>
<?rfc include="reference.RFC.3102"?>
<?rfc include="reference.RFC.3103"?>
<?rfc include="reference.RFC.3424"?>
<?rfc include="reference.RFC.3550"?>
<?rfc include="reference.RFC.3711"?>
<?rfc include="reference.RFC.3725"?>
<?rfc include="reference.RFC.3879"?>
<?rfc include="reference.RFC.4038"?>
<?rfc include="reference.RFC.4291"?>
<?rfc include="reference.RFC.4566"?>
<?rfc include="reference.RFC.2475"?>
<?rfc include="reference.RFC.1918"?>
<?rfc include="reference.RFC.4787"?>
<?rfc include="reference.RFC.5761"?>
<?rfc include="reference.RFC.4103"?>
<?rfc include="reference.RFC.4091"?>
<?rfc include="reference.RFC.4092"?>
<?rfc include="reference.RFC.5245"?>
<?rfc include="reference.RFC.5382"?>
<?rfc include="reference.RFC.5389"?>
<?rfc include="reference.RFC.6080"?>
<?rfc include="reference.RFC.6146"?>
<?rfc include="reference.RFC.6147"?>
<?rfc include="reference.RFC.6298"?>
<?rfc include="reference.RFC.6544"?>
<?rfc include="reference.RFC.6928"?>
<?rfc include="reference.RFC.7050"?>
<?rfc include="reference.RFC.7721"?>
<?rfc include="reference.RFC.7825"?>
<?rfc include="reference.I-D.ietf-mmusic-ice-sip-sdp"?>
<?rfc include="reference.I-D.ietf-ice-dualstack-fairness"?>
<?rfc include="reference.I-D.ietf-rtcweb-ip-handling"?>
</references>

<section anchor="sec-liteandfull" title="Lite and Full Implementations">

<t>
ICE allows for two types of implementations. A full implementation
supports the controlling and controlled roles in a session, and can
also perform address gathering. In contrast, a lite implementation is
a minimalist implementation that does little but respond to STUN
checks, and only supports the controlled role in a session.
</t>

<t>
Because ICE requires both endpoints to support it in order to bring
benefits to either endpoint, incremental deployment of ICE in a
network is more complicated. Many sessions involve an endpoint that
is, by itself, not behind a NAT and not one that would worry about NAT
traversal. A very common case is to have one endpoint that requires
NAT traversal (such as a VoIP hard phone or soft phone) make a call to
one of these devices. Even if the phone supports a full ICE
implementation, ICE won't be used at all if the other device doesn't
support it. The lite implementation allows for a low-cost entry point
for these devices. Once they support the lite implementation, full
implementations can connect to them and get the full benefits of ICE.
</t>

<t>
Consequently, a lite implementation is only appropriate for devices
that will *always* be connected to the public Internet and have a
public IP address at which it can receive packets from any
correspondent. ICE will not function when a lite implementation is
placed behind a NAT.
</t>

<t>
ICE allows a lite implementation to have a single IPv4 host candidate
and several IPv6 addresses. In that case, candidate pairs are selected
by the controlling agent using a static algorithm, such as the one in
RFC 6724, which is recommended by this specification. However, static
mechanisms for address selection are always prone to error, since they
cannot ever reflect the actual topology and can never provide actual
guarantees on connectivity. They are always heuristics. Consequently,
if an ICE agent is implementing ICE just to select between its IPv4 and
IPv6 addresses, and none of its IP addresses are behind NAT, usage
of full ICE is still RECOMMENDED in order to provide the most robust
form of address selection possible.
</t>

<t>
It is important to note that the lite implementation was added to this
specification to provide a stepping stone to full implementation. Even
for devices that are always connected to the public Internet with just
a single IPv4 address, a full implementation is preferable if
achievable. Full implementations also obtain
the security benefits of ICE unrelated to NAT traversal.
Finally, it is often the case that a device that finds
itself with a public address today will be placed in a network
tomorrow where it will be behind a NAT. It is difficult to
definitively know, over the lifetime of a device or product, that it
will always be used on the public Internet. Full implementation
provides assurance that communications will always work.
</t>

</section>

<section anchor="sec-designmotivations" title="Design Motivations">

<t>
ICE contains a number of normative behaviors that may themselves be
simple, but derive from complicated or non-obvious thinking or use
cases that merit further discussion. Since these design motivations
are not necessary to understand for purposes of implementation, they
are discussed here in an appendix to the specification. This section
is non-normative.
</t>


<section anchor="sec-pacing" title="Pacing of STUN Transactions">

<t>
STUN transactions used to gather candidates and to verify connectivity
are paced out at an approximate rate of one new transaction every Ta
milliseconds. Each transaction, in turn, has a retransmission timer
RTO that is a function of Ta as well. Why are these transactions
paced, and why are these formulas used?
</t>

<t> Sending of these STUN requests will often have the effect of
creating bindings on NAT devices between the client and the STUN
servers. Experience has shown that many NAT devices have upper limits
on the rate at which they will create new bindings. Experiments have
shown that once every 5 ms is well-supported.
This is why Ta has a lower bound of 5 ms. Furthermore,
transmission of these packets on the network makes use of bandwidth
and needs to be rate limited by the ICE agent. Deployments based on
earlier draft versions of <xref target="RFC5245"/> tended to overload
rate-constrained access links and perform poorly overall, in addition
to negatively impacting the network. As a consequence, the pacing
ensures that the NAT device does not get overloaded and that traffic
is kept at a reasonable rate.
</t>

<t>
The definition of a "reasonable" rate is that STUN MUST NOT use more
bandwidth than the RTP itself will use, once data starts flowing. The
formula for Ta is designed so that, if a STUN packet were sent every
Ta seconds, it would consume the same amount of bandwidth as RTP
packets, summed across all data streams. Of course, STUN has
retransmits, and the desire is to pace those as well. For this reason,
RTO is set such that the first retransmit on the first transaction
happens just as the first STUN request on the last transaction
occurs. Pictorially:
</t>

<figure><artwork>
<![CDATA[

           First Packets              Retransmits



                 |                        |
                 |                        |
          -------+------           -------+------
         /               \        /               \
        /                 \      /                 \

        +--+    +--+    +--+    +--+    +--+    +--+
        |A1|    |B1|    |C1|    |A2|    |B2|    |C2|
        +--+    +--+    +--+    +--+    +--+    +--+

     ---+-------+-------+-------+-------+-------+------------ Time
        0       Ta      2Ta     3Ta     4Ta     5Ta
]]></artwork></figure>

<t>
In this picture, there are three transactions that will be sent (for
example, in the case of candidate gathering, there are three host
candidate/STUN server pairs). These are transactions A, B, and C. The
retransmit timer is set so that the first retransmission on the first
transaction (packet A2) is sent at time 3Ta.
</t>

<t>
Subsequent retransmits after the first will occur even less frequently
than Ta milliseconds apart, since STUN uses an exponential back-off on
its retransmissions.
</t>

</section>

<section title="Candidates with Multiple Bases">

<t><xref target="sec-el-red"/> talks about eliminating candidates that
have the same transport address and base. However, candidates with the
same transport addresses but different bases are not redundant. When
can an ICE agent have two candidates that have the same IP address and
port, but different bases? Consider the topology of <xref
target="fig-horror-net"/>:
</t>


<figure title="Identical Candidates with Different Bases"
anchor="fig-horror-net"><artwork>
<![CDATA[

       +----------+
       | STUN Srvr|
       +----------+
            |
            |
          -----
        //     \\
       |         |
      |  B:net10  |
       |         |
        \\     //
          -----
            |
            |
       +----------+
       |   NAT    |
       +----------+
            |
            |
          -----
        //     \\
       |    A    |
      |192.168/16 |
       |         |
        \\     //
          -----
            |
            |
            |192.168.1.100      -----
       +----------+           //     \\             +----------+
       |          |          |         |            |          |
       | Initiator|---------|  C:net10  |-----------| Responder|
       |          |10.0.1.100|         | 10.0.1.101 |          |
       +----------+           \\     //             +----------+
                                -----


]]></artwork></figure>

<t>
In this case, the initiating agent is multihomed. It has one IP
address, 10.0.1.100, on network C, which is a net 10 private
network. The responding agent is on this same network. The initiating
agent is also connected to network A, which is 192.168/16 and has an
IP address of 192.168.1.100 on this network. There is a NAT on this
network, natting into network B, which is another net 10 private
network, but not connected to network C. There is a STUN server on
network B.
</t>

<t>
The initiating agent obtains a host candidate on its IP address on
network C (10.0.1.100:2498) and a host candidate on its IP address on
network A (192.168.1.100:3344). It performs a STUN query to its
configured STUN server from 192.168.1.100:3344. This query passes
through the NAT, which happens to assign the binding
10.0.1.100:2498. The STUN server reflects this in the STUN Binding
response. Now, the initiating agent has obtained a server reflexive
candidate with a transport address that is identical to a host
candidate (10.0.1.100:2498). However, the server reflexive candidate
has a base of 192.168.1.100:3344, and the host candidate has a base of
10.0.1.100:2498.
</t>


</section>

<section anchor="sec-translation" title="Purpose of the Related Address and Related Port Attributes">
<t>
The candidate attribute contains two values that are not used at all
by ICE itself -- related address and related port. Why are they
present?
</t>

<t>
There are two motivations for its inclusion. The first is
diagnostic. It is very useful to know the relationship between the
different types of candidates. By including it, an ICE agent can know
which relayed candidate is associated with which reflexive candidate,
which in turn is associated with a specific host candidate. When
checks for one candidate succeed and not for others, this provides
useful diagnostics on what is going on in the network.
</t>

<t>
The second reason has to do with off-path Quality of Service (QoS)
mechanisms. When ICE is used in environments such as PacketCable 2.0,
proxies will, in addition to performing normal SIP operations, inspect
the SDP in SIP messages, and extract the IP address and port for data
traffic. They can then interact, through policy servers, with access
routers in the network, to establish guaranteed QoS for the data
flows. This QoS is provided by classifying the RTP traffic based on
5-tuple, and then providing it a guaranteed rate, or marking its
Diffserv codepoints appropriately. When a residential NAT is present,
and a relayed candidate gets selected for data, this relayed
candidate will be a transport address on an actual TURN server. That
address says nothing about the actual transport address in the access
router that would be used to classify packets for QoS
treatment. Rather, the server reflexive candidate towards the TURN
server is needed. By carrying the translation in the SDP, the proxy
can use that transport address to request QoS from the access router.
</t>

</section>

<section anchor="sec-why-uname" title="Importance of the STUN Username">

<t>
ICE requires the usage of message integrity with STUN using its
short-term credential functionality. The actual short-term credential
is formed by exchanging username fragments in the candidate
exchange. The need for this mechanism goes beyond just security; it is
actually required for correct operation of ICE in the first place.
</t>

<t> Consider ICE agents L, R, and Z. L and R are within private enterprise
1, which is using 10.0.0.0/8. Z is within private enterprise 2, which
is also using 10.0.0.0/8. As it turns out, R and Z both have IP
address 10.0.1.1. L sends candidates to Z. Z, in responds L with its
host candidates. In this case, those candidates are 10.0.1.1:8866 and
10.0.1.1:8877. As it turns out, R is in a session at that same time,
and is also using 10.0.1.1:8866 and 10.0.1.1:8877 as host
candidates. This means that R is prepared to accept STUN messages on
those ports, just as Z is. L will send a STUN request to 10.0.1.1:8866
and another to 10.0.1.1:8877. However, these do not go to Z as
expected. Instead, they go to R! If R just replied to them, L would
believe it has connectivity to Z, when in fact it has connectivity to
a completely different user, R. To fix this, the STUN short-term
credential mechanisms are used. The username fragments are
sufficiently random that it is highly unlikely that R would be using
the same values as Z. Consequently, R would reject the STUN request
since the credentials were invalid. In essence, the STUN username
fragments provide a form of transient host identifiers, bound to a
particular session established as part of the candidate exchange.
</t>

<t>
An unfortunate consequence of the non-uniqueness of IP addresses is
that, in the above example, R might not even be an ICE agent. It could
be any host, and the port to which the STUN packet is directed could
be any ephemeral port on that host. If there is an application
listening on this socket for packets, and it is not prepared to handle
malformed packets for whatever protocol is in use, the operation of
that application could be affected. Fortunately, since the ports
exchanged are ephemeral and usually drawn from the dynamic or
registered range, the odds are good that the port is not used to run a
server on host R, but rather is the agent side of some protocol. This
decreases the probability of hitting an allocated port, due to the
transient nature of port usage in this range. However, the possibility
of a problem does exist, and network deployers need to be prepared for
it. Note that this is not a problem specific to ICE; stray packets can
arrive at a port at any time for any type of protocol, especially ones
on the public Internet. As such, this requirement is just restating a
general design guideline for Internet applications -- be prepared for
unknown packets on any port.
</t>

</section>

<section title="The Candidate Pair Priority Formula">

<t>
The priority for a candidate pair has an odd form. It is:
</t>

<t><list style="empty">
<t>pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)
</t>
</list></t>

<t>
Why is this? When the candidate pairs are sorted based on this value,
the resulting sorting has the MAX/MIN property. This means that the
pairs are first sorted based on decreasing value of the minimum of the
two priorities. For pairs that have the same value of the minimum
priority, the maximum priority is used to sort amongst them. If the
max and the min priorities are the same, the controlling agent's
priority is used as the tie-breaker in the last part of the
expression. The factor of 2*32 is used since the priority of a single
candidate is always less than 2*32, resulting in the pair priority
being a "concatenation" of the two component priorities.  This creates
the MAX/MIN sorting. MAX/MIN ensures that, for a particular ICE agent, a
lower-priority candidate is never used until all higher-priority
candidates have been tried.
</t>

</section>



<section title="Why Are Keepalives Needed?">

<t>
Once data begins flowing on a candidate pair, it is still necessary
to keep the bindings alive at intermediate NATs for the duration of
the session. Normally, the data stream packets themselves (e.g., RTP)
meet this objective. However, several cases merit further
discussion. Firstly, in some RTP usages, such as SIP, the data
streams can be "put on hold". This is accomplished by using the SDP
"sendonly" or "inactive" attributes, as defined in RFC 3264 <xref
target="RFC3264"/>. RFC 3264 directs implementations to cease
transmission of data in these cases. However, doing so may cause NAT
bindings to timeout, and data won't be able to come off hold.
</t>

<t>
Secondly, some RTP payload formats, such as the payload format for
text conversation <xref target="RFC4103"/>, may send
packets so infrequently that the interval exceeds the NAT binding
timeouts.
</t>

<t>
Thirdly, if silence suppression is in use, long periods of silence may
cause data transmission to cease sufficiently long for NAT bindings
to time out.
</t>

<t>
For these reasons, the data packets themselves cannot be relied
upon. ICE defines a simple periodic keepalive utilizing STUN Binding
indications.  This makes its bandwidth requirements highly
predictable, and thus amenable to QoS reservations.
</t>

</section>

<section title="Why Prefer Peer Reflexive Candidates?">

<t>
<xref target="sec-prioritizing"/> describes procedures for computing
the priority of candidate based on its type and local
preferences. That section requires that the type preference for peer
reflexive candidates always be higher than server reflexive. Why is
that? The reason has to do with the security considerations in <xref
target="sec-security"/>. It is much easier for an attacker to cause an
ICE agent to use a false server reflexive candidate than it is for an
attacker to cause an agent to use a false peer reflexive
candidate. Consequently, attacks against address gathering with
Binding requests are thwarted by ICE by preferring the peer reflexive
candidates.
</t>

</section>

<section title="Why Are Binding Indications Used for Keepalives?">

<t>
Data keepalives are described in <xref
target="sec-keepalives"/>. These keepalives make use of STUN when both
endpoints are ICE capable. However, rather than using a Binding
request transaction (which generates a response), the keepalives use
an Indication. Why is that?
</t>

<t>
The primary reason has to do with network QoS mechanisms. Once data
begins flowing, network elements will assume that the data stream has
a fairly regular structure, making use of periodic packets at fixed
intervals, with the possibility of jitter. If an ICE agent is sending
data packets, and then receives a Binding request, it would need to
generate a response packet along with its data packets. This will
increase the actual bandwidth requirements for the 5-tuple carrying
the data packets, and introduce jitter in the delivery of those
packets. Analysis has shown that this is a concern in certain layer 2
access networks that use fairly tight packet schedulers for data.
</t>

<t>
Additionally, using a Binding Indication allows integrity to be
disabled, allowing for better performance. This is useful for
large-scale endpoints, such as Public Switched Telephone Network (PSTN) 
gateways and Session Border Controllers (SBCs).
</t>

</section>

<section anchor="sec-candidate-type-preference" title="Selecting Candidate Type Preference">

<t>One criterion for selection of the type and local preference values
is the use of a data intermediary, such as a TURN server, a tunnel
service such as VPN server, or NAT. With a data intermediary, if
data is sent to that candidate, it will first transit the data
intermediary before being received. Relayed candidates are one type
of candidate that involves a data intermediary. Another are host
candidates obtained from a VPN interface. When data is transited
through a data intermediary, it can have a positive or negative
effect on the latency between transmission and reception. It may or
may not increase the packet losses, because of the additional router
hops that may be taken. It may increase the cost of providing
service, since data will be routed in and right back out of a data
intermediary run by a provider. If these concerns are important, the
type preference for relayed candidates needs to be carefully chosen.</t>

<t>Another criterion for selection of preferences is IP address
family. ICE works with both IPv4 and IPv6. It provides a transition
mechanism that allows dual-stack hosts to prefer connectivity over
IPv6, but to fall back to IPv4 in case the v6 networks are
disconnected. Implementation SHOULD follow the guidelines from <xref
target= "I-D.ietf-ice-dualstack-fairness"/> to avoid excessive delays
in the connectivity check phase if broken paths exist.</t>

<t>Another criterion for selecting preferences is topological
awareness. This is most useful for candidates that make use of
intermediaries. In those cases, if an ICE agent has preconfigured or
dynamically discovered knowledge of the topological proximity of the
intermediaries to itself, it can use that to assign higher local
preferences to candidates obtained from closer intermediaries.</t>

<t>Another criterion for selecting preferences might be security or
privacy. If a user is a telecommuter, and therefore connected to a
corporate network and a local home network, the user may prefer their
voice traffic to be routed over the VPN or similar tunnel in order to
keep it on the corporate network when communicating within the
enterprise, but use the local network when communicating with users
outside of the enterprise. In such a case, a VPN address would have a
higher local preference than any other address.</t>

</section>

</section>


<section anchor="sec-concheckbw" title="Connectivity Check Bandwidth">

<t>
The tables below show, for IPv4 and IPv6, the bandwidth required for
performing connectivity checks, using different Ta values (given in ms)
and different ufrag sizes (given in bytes).
</t>
<t>
The results were provided by Jusin Uberti (Google) 11th April 2016.
</t>
<figure title="Connectivity Check Bandwidth"
anchor="fig-concheckbw"><artwork>
<![CDATA[

IP version: IPv4
Packet len (bytes): 108 + ufrag
     |
  ms |     4     8    12    16
-----|------------------------
 500 | 1.86k 1.98k 2.11k 2.24k
 200 | 4.64k 4.96k 5.28k  5.6k
 100 | 9.28k 9.92k 10.6k 11.2k
  50 | 18.6k 19.8k 21.1k 22.4k
  20 | 46.4k 49.6k 52.8k 56.0k
  10 | 92.8k 99.2k  105k  112k
   5 |  185k  198k  211k  224k
   2 |  464k  496k  528k  560k
   1 |  928k  992k 1.06M 1.12M

IP version: IPv6
Packet len (bytes): 128 + ufrag
     |
  ms |     4     8    12    16
-----|------------------------
 500 | 2.18k  2.3k 2.43k 2.56k
 200 | 5.44k 5.76k 6.08k  6.4k
 100 | 10.9k 11.5k 12.2k 12.8k
  50 | 21.8k 23.0k 24.3k 25.6k
  20 | 54.4k 57.6k 60.8k 64.0k
  10 |  108k  115k  121k  128k
   5 |  217k  230k  243k  256k
   2 |  544k  576k  608k  640k
   1 | 1.09M 1.15M 1.22M 1.28M

]]></artwork></figure>


</section>

</back>
</rfc>
